/*****************************************************************************
 *                     Yumetech, Inc Copyright (c) 2004 - 2006
 *                               Java Source
 *
 * This source is licensed under the GNU LGPL v2.1
 * Please read http://www.gnu.org/copyleft/lgpl.html for more information
 *
 * This software comes with the standard NO WARRANTY disclaimer for any
 * purpose. Use it at your own risk. If there's a problem you get to fix it.
 *
 ****************************************************************************/

package org.j3d.aviatrix3d;

// External imports
import javax.vecmath.Matrix4f;

import javax.media.opengl.GL;

// Local imports
import org.j3d.aviatrix3d.picking.BoundingVolume;

/**
 * A Node class is the base class for all renderable nodes in the SceneGraph.
 *
 * @author Alan Hudson
 * @version $Revision: 1.26 $
 */
public abstract class Node extends SceneGraphObject
{
    /** Message for when the node is currently owned */
    private static final String CURRENT_PARENT_MSG =
        "Parent node currently set, and this node cannot have more than one " +
        "at a time. Please remove this node from it's current parent first " +
        "before adding it to another";

    /** Sharable version of the null bounds object for those that need it */
    protected static final BoundingVoid INVALID_BOUNDS = new BoundingVoid();

    /** The parent of this node */
    protected Node parent;

    /** Bounding volume set by the user */
    protected BoundingVolume bounds;

    /** Was the bounds automatically calculated? */
    protected boolean implicitBounds;

    /** Update handler for the external code. Not created until needed. */
    private InternalUpdater internalUpdater;

    /**
     * Internal implementation of the InternalNodeUpdateListener. Done as an
     * inner class to hide the calls from public consumption.
     */
    private class InternalUpdater
        implements InternalNodeUpdateListener
    {

        /**
         * Notify this node to update it's bounds now and propogate those new
         * bounds to their parent(s).
         */
        public void updateBoundsAndNotify()
        {
            updateBounds();
        }
    }


    /**
     * Construct a new instance of this node, with implicit bounds calculation.
     */
    protected Node()
    {
        implicitBounds = true;
        internalUpdater = new InternalUpdater();
    }

    //----------------------------------------------------------
    // Methods defined by SceneGraphObject
    //----------------------------------------------------------

    /**
     * Check to see if this node is the same reference as the passed node.
     * This is the upwards check to ensure that there is no cyclic scene graph
     * structures at the point where someone adds a node to the scenegraph.
     * When the reference and this are the same, an exception is generated.
     * If not, then the code will find the parent of this class and invoke
     * this same method on the parent.
     *
     * @param child The reference to check against this class
     * @throws CyclicSceneGraphStructureException Equal parent and child
     */
    protected void checkForCyclicParent(SceneGraphObject child)
        throws CyclicSceneGraphStructureException
    {
        super.checkForCyclicParent(child);

        if(parent != null)
            parent.checkForCyclicParent(child);
    }

    /**
     * Notification that this object is live now. Overrides the base class so
     * and recomputes the bounds locally if this is a transition to a live
     * state from non-live. It does not mark the parent node as being dirty,
     * just recalculates the current bounds.
     *
     * @param state true if this should be marked as live now
     */
    protected void setLive(boolean state)
    {
        boolean old_state = alive;

        super.setLive(state);

        // if we're coming live now, update the bounds.
        if(!old_state && state)
            recomputeBounds();
    }

    //----------------------------------------------------------
    // Local Methods
    //----------------------------------------------------------

    /**
     * Specify this nodes parent. Should not be called directly by external
     * callers. Setting a value of null will clear the existing parent. Bit
     * broken right now as it doesn't handle multiple-parents like needed in
     * a proper scene graph. If the node has a parent already, an exception
     * is generated. Note that this method is ignored if the derived type is
     * SharedGroup.
     *
     * @param p The new parent instance to call or null
     * @throws AlreadyParentedException There is a valid parent already set
     */
    protected void setParent(Node p)
        throws AlreadyParentedException
    {
        if(p != null && parent != null)
            throw new AlreadyParentedException(CURRENT_PARENT_MSG);

        parent = p;
    }

    /**
     * Remove a parent from this node. An alternate way to remove a parent
     * from the list.
     *
     * @param p The new parent instance to remove from the list
     */
    protected void removeParent(Node p)
    {
        parent = null;
    }

    /**
     * Get the current parent of this node. If no parent is set, return
     * null. Also, note that the behaviour of this method is to always
     * return null if the derived type of this class is SharedGroup.
     *
     * @return The current parent instance of the node
     */
    public Node getParent()
    {
        return parent;
    }

    /**
     * Notify the node that you have updates to the node that might alter
     * its bounds.
     *
     * @param l The change requestor
     * @throws InvalidListenerSetTimingException If called when the node is not live or
     *   if called during one of the bounds/data changed callbacks
     */
    public void boundsChanged(NodeUpdateListener l)
        throws InvalidListenerSetTimingException
    {
        if(!isLive())
            throw new InvalidListenerSetTimingException(LISTENER_SET_NOT_LIVE_MESSAGE);

        // Do nothing if not live
        if(updateHandler == null)
            return;

        if(updateHandler.boundsChanged(l, this, internalUpdater))
            markBoundsDirty();
    }

    /**
     * Set the bounds to the given explicit value. When set, auto computation
     * of the bounds of this node is turned off. A value of null can be used
     * to clear the current explicit bounds and return to auto computation.
     *
     * @param b The new bounds to use or null to clear
     */
    public void setBounds(BoundingVolume b)
    {
        if(isLive() && updateHandler != null &&
           !updateHandler.isBoundsWritePermitted(this))
            throw new InvalidWriteTimingException(WRITE_TIMING_MSG);

        bounds = b;
        implicitBounds = (bounds == null);
    }

    /**
     * Get the currently set bounds for this object. If no explicit bounds have
     * been set, then an implicit set of bounds is returned based on the
     * current scene graph state.
     *
     * @return The current bounds of this object
     */
    public BoundingVolume getBounds()
    {
        // need to check and set a new instance here if needed.
        if(implicitBounds && bounds == null)
            recomputeBounds();

        return bounds;
    }

    /**
     * Update this node's bounds. Used to propogate bounds changes from the
     * leaves of the tree to the root. A node implementation may decide when and
     * where to tell the parent(s)s that updates are ready, though typically it
     * is done in an overridden version of this method.
     */
    protected void updateBounds()
    {
    }

    /**
     * Update this node's parent bounds now. Used to propogate bounds changes
     * from the current level to the parent when needed. Typically used by
     * classes that extend the core nodes that do not automatically have access
     * to the updateBounds() method of any contained geometry, or of their own
     * parent.
     */
    protected void updateParentBounds()
    {
        if(parent != null)
            parent.updateBounds();
    }

    /**
     * Internal method to recalculate the implicit bounds of this Node. By
     * default the bounds are a BoundingVoid, so derived classes should
     * override this method with something better. It does not mark this node
     * as being dirty with it's parent.
     */
    protected void recomputeBounds()
    {
        if(bounds == null)
            bounds = INVALID_BOUNDS;
    }

    /**
     * Mark this node as having dirty bounds due to one of it's children having
     * their bounds changed. Default implementation will just call the parent
     * node and inform it that its bounds are dirty too.
     */
    protected void markBoundsDirty()
    {
        if(implicitBounds && (parent != null))
            parent.markBoundsDirty();
    }
}
