/*****************************************************************************
 *                     Yumetech, Inc Copyright (c) 2004 - 2006
 *                               Java Source
 *
 * This source is licensed under the GNU LGPL v2.1
 * Please read http://www.gnu.org/copyleft/lgpl.html for more information
 *
 * This software comes with the standard NO WARRANTY disclaimer for any
 * purpose. Use it at your own risk. If there's a problem you get to fix it.
 *
 ****************************************************************************/

package org.j3d.aviatrix3d.management;

// External imports
import java.lang.ref.SoftReference;
import java.lang.ref.Reference;
import java.lang.ref.ReferenceQueue;
import java.security.AccessController;
import java.security.PrivilegedAction;

// Local imports
import org.j3d.aviatrix3d.*;

import org.j3d.util.DefaultErrorReporter;
import org.j3d.util.ErrorReporter;
import org.j3d.util.HashSet;

import org.j3d.aviatrix3d.picking.PickingManager;
import org.j3d.aviatrix3d.pipeline.OutputDevice;
import org.j3d.aviatrix3d.pipeline.RenderPipeline;
import org.j3d.aviatrix3d.pipeline.audio.AudioOutputDevice;
import org.j3d.aviatrix3d.pipeline.audio.AudioRenderPipeline;
import org.j3d.aviatrix3d.pipeline.graphics.GraphicsRenderPipeline;
import org.j3d.aviatrix3d.pipeline.graphics.GraphicsOutputDevice;

import org.j3d.aviatrix3d.rendering.DeletableRenderable;
import org.j3d.aviatrix3d.rendering.ShaderSourceRenderable;

/**
 * Implementation of the {@link RenderManager} that uses separate
 * threads for each of the pipelines that it is managing, allowing it to run
 * multiple output surfaces simultaneously (eg Powerwall, CAVE etc).
 * <p>
 *
 * By default the manager does not start of enabled. An explicit enable call
 * will be needed to kick the management process off.
 * <p>
 *
 * Change List processing will process bounds changed items before data
 * changed.
 * <p>
 *
 * @author Justin Couch
 * @version $Revision: 1.4 $
 */
public class MultiThreadRenderManager
    implements Runnable,
               NodeUpdateHandler,
               RenderManager,
               PipelineStateObserver
{
    /** Message when trying to call renderOnce() while this is active */
    private static final String ACTIVE_RENDERING_MSG =
        "You cannot make this call now because the system is currently " +
        "management. To make this call, first disable the management. ";

    /** Message when the setLayers() call doesn't have an array big enough */
    private static final String LAYER_SET_SIZE_ERR =
        "The length of the layers argument is not long enough for the value " +
        "defined by numLayers";

    /** Message when attempting to set layers at the wrong time */
    private static final String LAYER_TIMING_MSG =
        "You cannot set layers right now. The system is actively management " +
        "and you did not make the call during the ApplicationUpdateObserver." +
        "updateSceneGraph() method callback.";

    /** Message when we've caught an error in userland code */
    private static final String USER_UPDATE_ERR =
        "An error was caught in user code during the processing of the " +
        "updateSceneGraph() method.";

    /** Message when we've caught an error during the appShutdown callback */
    private static final String USER_SHUTDOWN_ERR =
        "An error was caught in user code during the processing of the " +
        "appShutdown() method.";

    /** The initial size of the children list */
    private static final int CHANGELIST_START_SIZE = 200;

    /** The increment size of the list if it gets overflowed */
    private static final int CHANGELIST_INCREMENT = 100;

    /** The initial size of the shader init/log lists */
    private static final int SHADERLIST_START_SIZE = 64;

    /** The increment size of the init/log list if it gets overflowed */
    private static final int SHADERLIST_INCREMENT = 32;

    /** The manager for the layers */
    private LayerContainer layerContainer;

    /** The list of layers this pipeline manages */
    private Layer[] layers;

    /** The number of layers to process */
    private int numLayers;

    /** The change requestors for data changed sets */
    private NodeUpdateListener[] dataChangeList;

    /** The change requestors for bounds changed sets */
    private NodeUpdateListener[] boundsChangeList;

    /** The source objects for data changed sets */
    private Object[] dataSourceList;

    /** The source objects for bounds changed sets */
    private Object[] boundsSourceList;

    /** The internal requestors for bounds changed sets */
    private InternalNodeUpdateListener[] boundsInternalList;

    /** The current place to add change requestors */
    private int lastDataChangeItem;

    /** The current place to add change requestors */
    private int lastBoundsChangeItem;

    /** HashSet to determine duplicates in the change List */
    private HashSet dataChangeListenerSet;

    /** HashSet to determine duplicates in the change List */
    private HashSet dataChangeSrcSet;

    /** HashSet to determine duplicates in the change List */
    private HashSet boundsChangeListenerSet;

    /** HashSet to determine duplicates in the change List */
    private HashSet boundsChangeSrcSet;

    /** The change requestors for data changed sets */
    private ShaderSourceRenderable[] shaderInitList;

    /** The change requestors for bounds changed sets */
    private ShaderSourceRenderable[] shaderLogList;

    /** The current place to add shader init requestors */
    private int lastShaderInitItem;

    /** The current place to add shader log requestors */
    private int lastShaderLogItem;

    /** Set of shaders that require init processing */
    private HashSet shaderInitSet;

    /** Set of shaders that require log fetch processing */
    private HashSet shaderLogSet;

    /** The collection of pipeleines to manage */
    private GraphicsRenderPipeline[] pipeline;

    /** The collection of pipeleines to manage */
    private AudioRenderPipeline[] audioPipeline;

    /** Threads that manage a pipeline. Thread corresponds to pipeline index */
    private GraphicsPipelineThread[] pipelineThread;

    /** Threads that manage a pipeline. Thread corresponds to pipeline index */
    private AudioPipelineThread[] audioPipelineThread;

    /** Number of valid pipelines to process */
    private int numGraphicsPipes;

    /** Number of valid audio pipelines to process */
    private int numAudioPipes;

    /** Picking handler for managing the picking */
    private PickingManager pickHandler;

    /** The minimum frame cycle time */
    private int minimumCycleTime;

    /** Current enabled state */
    private boolean enabled;

    /** The thread that contains this runnable */
    private Thread runtimeThread;

    /** Flag that the runtime thread should be terminated at next chance */
    private boolean terminate;

    /** The external observer for keeping updates in check */
    private ApplicationUpdateObserver observer;

    /** Queue for holding deleted textures */
    private ReferenceQueue deletionQueue;

    /** Flag for the writable state used by the NodeUpdateHandler query */
    private boolean pickPermitted;

    /** The current object that is having the update callback called */
    private Object writableBoundsObject;

    /** The current object that is having the update callback called */
    private Object writableDataObject;

    /**
     * Lock object to prevent frame callbacks from finishing before we've
     * called all the other threads this frame.
     */
    private Object frameFinishLock;

    /** Per-frame counter used to track when a frame is complete */
    private int completedFrameCount;

    /** Object to synchronise between the various management threads */
    private Object renderWaitLock;

    /** Are we processing the change list */
    private boolean processing;

    /**
     * Flag indicating if we should halt the management cycle if an error is
     * detected during the management loop process. Set to true by default.
     */
    private boolean haltOnError;

    /**
     * Flag indicating that the scene has changed and it should be completely
     * rendered and not just skip to the display part.
     */
    private boolean sceneChanged;

    /** The thread used to handle the system shutdown hook */
    private Thread shutdownThread;

    /** Error reporter used to send out messages */
    private ErrorReporter errorReporter;

    /**
     * Construct a new render manager with no pipelines or renderers
     * registered. Starts by allocating space for 2 render pipes and
     * 1 audio pipe to be handled.
     */
    public MultiThreadRenderManager()
    {
        this(2, 1);
    }

    /**
     * Construct a new render manager with no pipelines or renderers
     * registered, but with internal arrays setup for the given number of
     * pipelines to be added.
     *
     * @param numPipes The initial number of pipelines to prepare
     * @param numAudioPipes The initial number of audio pipelines to prepare
     */
    public MultiThreadRenderManager(int numPipes, int numAudioPipes)
    {
        enabled = false;
        terminate = false;
        processing = false;

        pickPermitted = false;
        sceneChanged = false;
        haltOnError = true;

        pipeline = new GraphicsRenderPipeline[numPipes];
        pipelineThread = new GraphicsPipelineThread[numPipes];

        audioPipeline = new AudioRenderPipeline[numAudioPipes];
        audioPipelineThread = new AudioPipelineThread[numAudioPipes];

        renderWaitLock = new Object();
        frameFinishLock = new Object();

        dataChangeList = new NodeUpdateListener[CHANGELIST_START_SIZE];
        dataSourceList = new Object[CHANGELIST_START_SIZE];
        dataChangeListenerSet = new HashSet(CHANGELIST_START_SIZE);
        dataChangeSrcSet = new HashSet(CHANGELIST_START_SIZE);
        boundsChangeList = new NodeUpdateListener[CHANGELIST_START_SIZE];
        boundsInternalList =
            new InternalNodeUpdateListener[CHANGELIST_START_SIZE];
        boundsSourceList = new Object[CHANGELIST_START_SIZE];
        boundsChangeListenerSet = new HashSet(CHANGELIST_START_SIZE);
        boundsChangeSrcSet = new HashSet(CHANGELIST_START_SIZE);
        shaderInitList = new ShaderSourceRenderable[SHADERLIST_START_SIZE];
        shaderInitSet = new HashSet(SHADERLIST_START_SIZE);
        shaderLogList = new ShaderSourceRenderable[SHADERLIST_START_SIZE];
        shaderLogSet = new HashSet(SHADERLIST_START_SIZE);

        pickHandler = new DefaultPickingHandler();
        deletionQueue = new ReferenceQueue();

        lastDataChangeItem = 0;
        lastBoundsChangeItem = 0;
        lastShaderInitItem = 0;
        lastShaderLogItem = 0;

        minimumCycleTime = 0;
        completedFrameCount = 0;

        layerContainer = new LayerContainer();
        layerContainer.setUpdateHandler(this);

        layers = new Layer[1];
        errorReporter = DefaultErrorReporter.getDefaultReporter();

        shutdownThread = new ShutdownThread(this);
        AccessController.doPrivileged(
            new PrivilegedAction()
            {
                public Object run()
                {
                        Runtime rt = Runtime.getRuntime();
                        rt.addShutdownHook(shutdownThread);
                        return null;
                }
            }
        );
    }

    //---------------------------------------------------------------
    // Methods defined by RenderManager
    //---------------------------------------------------------------

    /**
     * Register an error reporter with the engine so that any errors generated
     * by the node's internals can be reported in a nice, pretty fashion.
     * Setting a value of null will clear the currently set reporter. If one
     * is already set, the new value replaces the old.
     *
     * @param reporter The instance to use or null
     */
    public void setErrorReporter(ErrorReporter reporter)
    {
        if(reporter == null)
            errorReporter = DefaultErrorReporter.getDefaultReporter();
        else
            errorReporter = reporter;

        pickHandler.setErrorReporter(errorReporter);
    }

    /**
     * Set whether the manager should automatically halt management if an error
     * or exception is detected during the user callback processing. If this is
     * set to true (the default) then processing immediately halts and sets the
     * state to disabled as soon as an error is detected. The management
     * contexts are not disposed of. We just terminate the current management
     * process if this is detected.
     * <p>
     * If the value is set to false, then the error is caught, but management
     * continues on regardless.
     * <p>
     * In both states, the error that is caught is reported through the
     * currently registered {@link ErrorReporter} instance as an error message.
     *
     * @param state true to enable halting, false to disable
     */
    public void setHaltOnError(boolean state)
    {
        haltOnError = state;
    }

    /**
     * Check to see the current halt on error state.
     *
     * @return true if the system halts on an error condition
     * @see #setHaltOnError
     */
    public boolean isHaltingOnError()
    {
        return haltOnError;
    }

    /**
     * Tell render to start or stop management. If currently running, it
     * will wait until all the pipelines have completed their current cycle
     * and will then halt.
     *
     * @param state True if to enable management
     */
    public synchronized void setEnabled(boolean state)
    {
        if(enabled == state)
            return;

        if(state)
        {
            enabled = true;
            terminate = false;
            pickPermitted = false;

            if(runtimeThread == null)
            {
                ThreadPrivilegedAction tpa = new ThreadPrivilegedAction(this);
                runtimeThread = tpa.getThread();
            }
        }
        else
        {
            enabled = false;
            terminate = true;
            pickPermitted = true;

            for(int i = 0; i < numGraphicsPipes; i++)
                pipelineThread[i].halt();

            for(int i = 0; i < numAudioPipes; i++)
                audioPipelineThread[i].halt();
        }
    }

    /**
     * Get the current render state of the manager.
     *
     * @return true if the manager is currently running
     */
    public boolean isEnabled()
    {
        return enabled;
    }

    /**
     * Force a single render of all pipelines now. Ignores the enabled and
     * cycle time settings to cause a single render at this point in time.
     * If a render is currently in progress, an exception is generated
     *
     * @throws IllegalStateException The system is currently management and
     *   should be disabled first.
     */
    public synchronized void renderOnce()
        throws IllegalStateException
    {
        if(enabled)
            throw new IllegalStateException(ACTIVE_RENDERING_MSG);

        processChangeList();
        processShaderLists();

        if(numLayers == 0)
            return;

        for(int i = 0; i < numGraphicsPipes; i++)
            pipelineThread[i].render();

        for(int i = 0; i < numAudioPipes; i++)
            audioPipelineThread[i].render();

        for(int i = 0; i < numGraphicsPipes; i++)
            pipeline[i].swapBuffers();
    }

    /**
     * Request that the manager perform a full scene render pass and update,
     * ignoring any usual optimisations that it may take. For performance
     * reasons, a render manager may elect to not run or update some portions
     * of the scene graph. This method requests that the next frame only should
     * ignore those optimisations and process the full scene graph.
     * <p>
     *
     * This method will work both in automated management and with the
     * {@link #renderOnce()} method.
     */
    public void requestFullSceneRender()
    {
        sceneChanged = true;
    }

    /**
     * Set the set of layers for this manager. Setting a value of
     * <code>null</code> will remove the currently set of layers. If this is
     * set while a current scene is set, then the scene will be cleared. Layers
     * are presented in depth order - layers[0] is rendered before layers[1]
     * etc.
     *
     * @param layers The collection of layers, in order, to render
     * @param numLayers The number of valid layers to use
     * @throws IllegalArgumentException The length of the layers array is less
     *    than numLayers
     * @throws InvalidWriteTimingException The method was called with the
     *    system enabled and not during the app observer callback
     */
    public void setLayers(Layer[] layers, int numLayers)
        throws IllegalArgumentException, InvalidWriteTimingException
    {
        if(enabled && !pickPermitted)
            throw new InvalidWriteTimingException(LAYER_TIMING_MSG);

        int size = layers == null ? 0 : layers.length;
        if(size < numLayers)
            throw new IllegalArgumentException(LAYER_SET_SIZE_ERR);

        if(this.layers.length < numLayers)
            this.layers = new Layer[numLayers];

        System.arraycopy(layers, 0, this.layers, 0, numLayers);
        this.numLayers = numLayers;

        layerContainer.setLive(false);

        for(int i = 0; i < numLayers; i++)
            layerContainer.addChild(layers[i]);

        layerContainer.setLive(true);

        for(int i = 0; i < numGraphicsPipes; i++)
            pipeline[i].setRenderableLayers(layers, numLayers);

        for(int i = 0; i < numAudioPipes; i++)
            audioPipeline[i].setRenderableLayers(layers, numLayers);

       sceneChanged = true;
    }

    /**
     * Get the number of layers that are currently set. If no layers are set,
     * or a scene is set, this will return zero.
     *
     * @return a value greater than or equal to zero
     */
    public int numLayers()
    {
        return numLayers;
    }

    /**
     * Fetch the current layers that are set. The values will be copied into
     * the user-provided array. That array must be at least
     * {@link #numLayers()} in length. If not, this method does nothing (the
     * provided array will be unchanged).
     *
     * @param layers An array to copy the values into
     */
    public void getLayers(Layer[] layers)
    {
        if((layers == null) || (layers.length < numLayers))
            return;

        System.arraycopy(this.layers, 0, layers, 0, numLayers);
    }

    /**
     * Set the minimum duty cycle of the render manager. This is the type in
     * milliseconds that should be the minimum between frames and can be used
     * to throttle the management loop to a maximum frame rate should other
     * systems require CPU time.
     *
     * @param cycleTime The minimum time in milliseconds between frames
     */
    public void setMinimumFrameInterval(int cycleTime)
    {
        minimumCycleTime = cycleTime;
    }

    /**
     * Fetch the currently set duty cycle value.
     *
     * @return The duty cycle time, in milliseconds
     */
    public int getMinimumFrameInterval()
    {
        return minimumCycleTime;
    }

    /**
     * Add a pipeline to be rendered to the manager. A duplicate registration
     * or null value is ignored. For this implementation, a call to this method
     * will replace the existing pipeline rather than add an additional one.
     *
     * @param pipe The new pipe instance to be added
     * @throws IllegalStateException The system is currently management and
     *   should be disabled first.
     */
    public void addPipeline(RenderPipeline pipe)
        throws IllegalStateException
    {
        if(enabled)
            throw new IllegalStateException(ACTIVE_RENDERING_MSG);

        if(pipe == null)
            return;

        if(pipe instanceof GraphicsRenderPipeline)
        {
            if(numGraphicsPipes == pipeline.length)
            {
                GraphicsRenderPipeline[] tmp1 =
                    new GraphicsRenderPipeline[numGraphicsPipes + 2];
                System.arraycopy(pipeline, 0, tmp1, 0, numGraphicsPipes);
                pipeline = tmp1;

                GraphicsPipelineThread[] tmp2 =
                    new GraphicsPipelineThread[numGraphicsPipes + 2];
                System.arraycopy(pipelineThread, 0, tmp2, 0, numGraphicsPipes);
                pipelineThread = tmp2;
            }

            pipe.setRenderableLayers(layers, numLayers);

            GraphicsRenderPipeline gp = (GraphicsRenderPipeline)pipe;
            pipeline[numGraphicsPipes] = gp;
            pipelineThread[numGraphicsPipes] = new GraphicsPipelineThread(gp);
            pipelineThread[numGraphicsPipes].setStateObserver(this);

            numGraphicsPipes++;
        }
        else if(pipe instanceof AudioRenderPipeline)
        {
            if(numAudioPipes == audioPipeline.length)
            {
                AudioRenderPipeline[] tmp1 =
                    new AudioRenderPipeline[numAudioPipes + 2];
                System.arraycopy(audioPipeline, 0, tmp1, 0, numAudioPipes);
                audioPipeline = tmp1;

                AudioPipelineThread[] tmp2 =
                    new AudioPipelineThread[numAudioPipes + 2];
                System.arraycopy(audioPipelineThread, 0, tmp2, 0, numAudioPipes);
                audioPipelineThread = tmp2;
            }

            pipe.setRenderableLayers(layers, numLayers);

            AudioRenderPipeline ap = (AudioRenderPipeline)pipe;
            audioPipeline[numAudioPipes] = ap;
            audioPipelineThread[numAudioPipes] = new AudioPipelineThread(ap);
            audioPipelineThread[numAudioPipes].setStateObserver(this);

            numAudioPipes++;
        }
    }

    /**
     * Remove an already registered pipeline from the manager. A or null value
     * or one that is not currently registered is ignored. For this
     * implementation, a call to this method will remove the existing pipeline
     * if it is the same instance rather than remove an additional one.
     *
     * @param pipe The pipe instance to be removed
     * @throws IllegalStateException The system is currently management and
     *   should be disabled first.
     */
    public void removePipeline(RenderPipeline pipe)
        throws IllegalStateException
    {
        if(enabled)
            throw new IllegalStateException(ACTIVE_RENDERING_MSG);

        if(pipe instanceof GraphicsRenderPipeline)
        {
            for(int i = 0; i < numGraphicsPipes; i++)
            {
                if(pipeline[i] == pipe)
                {
                    pipelineThread[i].shutdown();
                    pipelineThread[i].setStateObserver(null);

                    System.arraycopy(pipeline,
                                     i + 1,
                                     pipeline,
                                     i,
                                     numGraphicsPipes - i - 1);

                    System.arraycopy(pipelineThread,
                                     i + 1,
                                     pipelineThread,
                                     i,
                                     numGraphicsPipes - i - 1);

                    numGraphicsPipes--;
                    pipe.setRenderableLayers(null, 0);

                    break;
                }
            }
        }
        else if(pipe instanceof AudioRenderPipeline)
        {
            for(int i = 0; i < numAudioPipes; i++)
            {
                if(audioPipeline[i] == pipe)
                {
                    audioPipelineThread[i].shutdown();
                    audioPipelineThread[i].setStateObserver(null);

                    System.arraycopy(audioPipeline,
                                     i + 1,
                                     pipeline,
                                     i,
                                     numAudioPipes - i - 1);

                    System.arraycopy(audioPipelineThread,
                                     i + 1,
                                     audioPipelineThread,
                                     i,
                                     numAudioPipes - i - 1);

                    numAudioPipes--;
                    pipe.setRenderableLayers(null, 0);

                    break;
                }
            }
        }
    }

    /**
     * Register an observer that can be used to know when the application is
     * safe to update the scene graph. A value of null will remove the
     * currently set value.
     *
     * @param obs The observer instance to use
     */
    public void setApplicationObserver(ApplicationUpdateObserver obs)
    {
        observer = obs;
    }

    /**
     * Disable the internal shutdown hook system. It will be up to the calling
     * application to make sure the {@link #shutdown()} method is called to
     * turn off the OpenGL management system. If it does not, there is a good
     * possibility of a crash of the system.
     * <p>
     *
     * If the internal shutdown is disabled, then the shutdown callback of the
     * <code>ApplicationUpdateObserver</code> will not be called.
     */
    public void disableInternalShutdown()
    {
        if(shutdownThread != null)
        {
            AccessController.doPrivileged(
                new PrivilegedAction()
                {
                    public Object run()
                    {
                        Runtime rt = Runtime.getRuntime();
                        rt.removeShutdownHook(shutdownThread);
                        return null;
                    }
                }
            );

            shutdownThread = null;
        }
    }

    /**
     * Notification to shutdown the internals of the renderer because the
     * application is about to exit.
     */
    public synchronized void shutdown()
    {
        // If this has already been called once, ignore it. Most of the
        // variables will have been nulled out by now.
        if(terminate || !enabled)
            return;

        terminate = true;

        setEnabled(false);

        // If we have a shutdown thread then that means
        if((shutdownThread != null) && (observer != null))
        {
            try
            {
                observer.appShutdown();
            }
            catch(Exception e)
            {
                errorReporter.errorReport(USER_SHUTDOWN_ERR, e);
            }

            observer = null;
        }
    }

    //---------------------------------------------------------------
    // Methods defined by Runnable
    //---------------------------------------------------------------

    /**
     * Run method used to synchronise the internal management state and the
     * external state of the canvas. Should never be called directly.
     */
    public void run()
    {
        for(int i = 0; i < numGraphicsPipes; i++)
        {
            if(!pipelineThread[i].isAlive())
                pipelineThread[i].start();
        }

        for(int i = 0; i < numAudioPipes; i++)
        {
            if(!audioPipelineThread[i].isAlive())
                audioPipelineThread[i].start();
        }

        while(!terminate)
        {
            // Throttle the apps runtime
            long start_time = System.currentTimeMillis();

            if(!terminate && observer != null)
            {
                pickPermitted = true;

                try
                {
                    observer.updateSceneGraph();
                }
                catch(Exception e)
                {
                    errorReporter.errorReport(USER_UPDATE_ERR, e);
                    if(haltOnError)
                    {
                        enabled = false;
                        return;
                    }
                }
                finally
                {
                    pickPermitted = false;
                }
            }

            if(terminate)
                break;

            // Look out for any deleted objects and hand them on if needed.
            Reference ref;

            while((ref = deletionQueue.poll()) != null)
            {
                DeletableRenderable dead =
                    (DeletableRenderable)ref.get();

                for(int i = 0; i < numGraphicsPipes; i++)
                    pipelineThread[i].queueDeletedObject(dead);
            }

            if(terminate)
                break;

            processShaderLists();

            if(terminate)
                break;

            synchronized(frameFinishLock)
            {
                // Can we skip the processing if nothing changed last frame?
                if((lastDataChangeItem == 0) && (lastBoundsChangeItem == 0) &&
                   !sceneChanged)
                {
                    for(int i = 0; i < numGraphicsPipes && !terminate; i++)
                        pipelineThread[i].displayOnly();

                    for(int i = 0; i < numAudioPipes && !terminate; i++)
                        audioPipelineThread[i].displayOnly();
                }
                else
                {
                    processChangeList();

                    if(terminate)
                        break;

                    sceneChanged = false;

                    for(int i = 0; i < numGraphicsPipes && !terminate; i++)
                        pipelineThread[i].render();

                    for(int i = 0; i < numAudioPipes && !terminate; i++)
                        audioPipelineThread[i].render();
                }

                if(terminate)
                    break;
            }

            // Hang while we wait for notification that all the management
            // threads have finished before swapping all the buffers.
            if(!terminate && (numGraphicsPipes + numAudioPipes) != 0)
            {
                try
                {
                    synchronized(renderWaitLock)
                    {
                        renderWaitLock.wait();
                    }
                }
                catch(InterruptedException ie)
                {
                }
            }

            if(terminate)
                break;

            long now = System.currentTimeMillis();
            long diff = now - start_time;

            if(diff < minimumCycleTime)
            {
                try
                {
                    Thread.sleep(minimumCycleTime - diff);
                }
                catch(InterruptedException ie)
                {
                }
            }

            Thread.yield();
        }

        runtimeThread = null;
    }

    //---------------------------------------------------------------
    // Methods defined by PipelineStateObserver
    //---------------------------------------------------------------

    /**
     * Notification that the frame state has finished management.
     */
    public synchronized void frameFinished()
    {
        synchronized(frameFinishLock)
        {
            if(++completedFrameCount >= (numGraphicsPipes + numAudioPipes))
            {
                synchronized(renderWaitLock)
                {
                    completedFrameCount = 0;
                    renderWaitLock.notify();
                }
            }
        }
    }

    //---------------------------------------------------------------
    // Methods defined by NodeUpdateHandler
    //---------------------------------------------------------------

    /**
     * Check to see if writing to the node is permitted currently.
     *
     * @param src The object that is requesting the check
     * @return true if the end user can write, false if not
     */
    public boolean isDataWritePermitted(Object src)
    {
        return (src == writableDataObject) || !enabled;
    }

    /**
     * Check to see if writing to the node is permitted currently.
     *
     * @param src The object that is requesting the check
     * @return true if the end user can write, false if not
     */
    public boolean isBoundsWritePermitted(Object src)
    {
        return (src == writableBoundsObject) || !enabled;
    }

    /**
     * Check to see if picking is permitted currently.
     *
     * @return true if the end user can pick, false if not
     */
    public boolean isPickingPermitted()
    {
        return !enabled || pickPermitted;
    }

    /**
     * Feedback to the internals that a data object has changed and it requires
     * re-management. This should only be called by classes that can effect the
     * management but don't normally use the data/bounds write listeners (ie
     * changes are made during the app update portion of the scene graph).
     * Typically this would be used for things like the {@link ViewEnvironment}
     * changing the aspect ratio etc.
     */
    public void notifyUpdateRequired()
    {
        sceneChanged = true;
    }

    /**
     * Notify the handler that you have updates to the SG that might alter
     * a node's bounds.
     *
     * @param l The change requestor
     * @param src The object that is passing this listener through.
     * @param intL Internal listener for making callbacks at a later time
     *    to propogate the bounds changes.
     * @throws InvalidListenerSetTimingException If called when the node called
     *    during one of the bounds/data changed callbacks
     */
    public synchronized boolean boundsChanged(NodeUpdateListener l,
                                              Object src,
                                              InternalNodeUpdateListener intL)
        throws InvalidListenerSetTimingException
    {
        if(processing)
            throw new InvalidListenerSetTimingException("boundsChanged cannot be called in NodeUpdateListener");

        // Check for duplicates
        if(boundsChangeSrcSet.contains(src) && boundsChangeListenerSet.contains(l)) {
            return false;
        }

        boundsChangeListenerSet.add(l);
        boundsChangeSrcSet.add(src);

        // Add to a single ChangeList for now
        resizeBoundsChangeList();
        boundsChangeList[lastBoundsChangeItem] = l;
        boundsInternalList[lastBoundsChangeItem] = intL;
        boundsSourceList[lastBoundsChangeItem] = src;
        lastBoundsChangeItem++;

        return true;
    }

    /**
     * Notify the handler that you have updates to the SG that will not
     * alter a node's bounds.
     *
     * @param l The change requestor
     * @param src The object that is passing this listener through.
     * @throws InvalidListenerSetTimingException If called when the node called
     *    during one of the bounds/data changed callbacks
     */
    public synchronized void dataChanged(NodeUpdateListener l, Object src)
        throws InvalidListenerSetTimingException
    {
        if(processing)
            throw new InvalidListenerSetTimingException("dataChanged cannot be called in NodeUpdateListener.  Need to fix for threaded content.");

        // Check for duplicates
        if(dataChangeSrcSet.contains(src) &&
           dataChangeListenerSet.contains(l))
            return;

        dataChangeListenerSet.add(l);
        dataChangeSrcSet.add(src);

        // Add to a single ChangeList for now
        resizeDataChangeList();
        dataChangeList[lastDataChangeItem] = l;
        dataSourceList[lastDataChangeItem] = src;
        lastDataChangeItem++;
    }

    /**
     * The shader object passed requires an initialisation be performed. Queue
     * the shader up for processing now.
     *
     * @param shader The shader instance to queue
     * @param updateResponse true if this is being made as a response to a node's
     *   setUpdateHandler() method
     */
    public void shaderRequiresInit(ShaderSourceRenderable shader,
                                   boolean updateResponse)
    {
        if(processing && !updateResponse)
            throw new RuntimeException("shaderRequiresInit cannot be called in NodeUpdateListener");

        // Check for duplicates
        if(shaderInitSet.contains(shader))
            return;

        shaderInitSet.add(shader);

        resizeShaderInitList();
        shaderInitList[lastShaderInitItem] = shader;
        lastShaderInitItem++;
    }

    /**
     * The shader object passed requires updating the log info. Queue
     * the shader up for processing now so that at the next oppourtunity it
     * can call glGetLogInfoARB.
     *
     * @param shader The shader instance to queue
     * @param updateResponse true if this is being made as a response to a node's
     *   setUpdateHandler() method
     */
    public void shaderRequiresLogInfo(ShaderSourceRenderable shader,
                                      boolean updateResponse)
    {
        if(processing && !updateResponse)
            throw new RuntimeException("shaderRequiresLog cannot be called in NodeUpdateListener");

        // Check for duplicates
        if(shaderLogSet.contains(shader))
            return;

        shaderLogSet.add(shader);

        resizeShaderLogList();
        shaderLogList[lastShaderLogItem] = shader;
        lastShaderLogItem++;
    }

    /**
     * The object provided is no longer needed by its parent. Put this on
     * a queue for objects that could potentially be deleted next frame. Used
     * for any scene graph object type that must be explicitly cleaned up
     * during the OpenGL render cycle, such as textures and pBuffers.
     *
     * @param obj The object that is registering itself for deletion
     */
    public void objectRemoved(DeletableRenderable obj)
    {
        new SoftReference(obj, deletionQueue);
    }

    /**
     * Get the picking handler so that we can do some picking operations.
     *
     * @return the current instance of the picking system
     */
    public PickingManager getPickingManager()
    {
        return pickHandler;
    }

    //---------------------------------------------------------------
    // Misc Internal methods
    //---------------------------------------------------------------

    /**
     * Process the changeList now.
     */
    private void processChangeList()
    {
        processing = true;

        for(int i = 0; i < lastBoundsChangeItem; i++)
        {
            writableBoundsObject = boundsSourceList[i];
            boundsChangeList[i].updateNodeBoundsChanges(boundsSourceList[i]);
            boundsChangeList[i] = null;
            boundsSourceList[i] = null;
        }

        writableBoundsObject = null;

        // Now go through and update all the bounds
        for(int i = 0; i < lastBoundsChangeItem; i++)
        {
            boundsInternalList[i].updateBoundsAndNotify();
            boundsInternalList[i] = null;
        }

        lastBoundsChangeItem = 0;
        boundsChangeSrcSet.clear();
        boundsChangeListenerSet.clear();

        for(int i = 0; i < lastDataChangeItem; i++)
        {
            writableDataObject = dataSourceList[i];
            dataChangeList[i].updateNodeDataChanges(dataSourceList[i]);
            dataChangeList[i] = null;
            dataSourceList[i] = null;
        }

        writableDataObject = null;
        lastDataChangeItem = 0;
        dataChangeSrcSet.clear();
        dataChangeListenerSet.clear();

        processing = false;
    }

    /**
     * Process the shader lists and pass them on to the drawable for processing
     * next frame.
     */
    private void processShaderLists()
    {
        if((lastShaderInitItem == 0) && (lastShaderLogItem == 0))
            return;

        for(int i = 0; i < numGraphicsPipes; i++)
        {
            pipelineThread[i].queueShaderRequests(shaderInitList,
                                                  lastShaderInitItem,
                                                  shaderLogList,
                                                  lastShaderLogItem);
        }

        // now clear out the array.
        for(int i = 0; i < lastShaderInitItem; i++)
            shaderInitList[0] = null;

        for(int i = 0; i < lastShaderLogItem; i++)
            shaderLogList[0] = null;

        lastShaderInitItem = 0;
        lastShaderLogItem = 0;

        shaderInitSet.clear();
        shaderLogSet.clear();
    }

    /**
     * Resize the list if needed. Marked as final in order to encourage the
     * compiler to inline the code for faster execution
     */
    private final void resizeDataChangeList()
    {
        if((lastDataChangeItem + 1) == dataChangeList.length)
        {
            int old_size = dataChangeList.length;
            int new_size = old_size + CHANGELIST_INCREMENT;

            NodeUpdateListener[] tmp_nodes = new NodeUpdateListener[new_size];
            Object[] tmp_src = new Object[new_size];

            System.arraycopy(dataChangeList, 0, tmp_nodes, 0, old_size);
            System.arraycopy(dataSourceList, 0, tmp_src, 0, old_size);

            dataChangeList = tmp_nodes;
            dataSourceList = tmp_src;
        }
    }

    /**
     * Resize the list if needed. Marked as final in order to encourage the
     * compiler to inline the code for faster execution
     */
    private final void resizeBoundsChangeList()
    {
        if((lastBoundsChangeItem + 1) == boundsChangeList.length)
        {
            int old_size = boundsChangeList.length;
            int new_size = old_size + CHANGELIST_INCREMENT;

            NodeUpdateListener[] tmp_nodes = new NodeUpdateListener[new_size];
            InternalNodeUpdateListener[] tmp_int =
                new InternalNodeUpdateListener[new_size];
            Object[] tmp_src = new Object[new_size];

            System.arraycopy(boundsChangeList, 0, tmp_nodes, 0, old_size);
            System.arraycopy(boundsSourceList, 0, tmp_src, 0, old_size);
            System.arraycopy(boundsInternalList, 0, tmp_int, 0, old_size);

            boundsChangeList = tmp_nodes;
            boundsSourceList = tmp_src;
            boundsInternalList = tmp_int;
        }
    }


    /**
     * Resize the list if needed. Marked as final in order to encourage the
     * compiler to inline the code for faster execution
     */
    private final void resizeShaderInitList()
    {
        if((lastShaderInitItem + 1) == shaderInitList.length)
        {
            int old_size = shaderInitList.length;
            int new_size = old_size + SHADERLIST_INCREMENT;

            ShaderSourceRenderable[] tmp_nodes =
                new ShaderSourceRenderable[new_size];

            System.arraycopy(shaderInitList, 0, tmp_nodes, 0, old_size);

            shaderInitList = tmp_nodes;
        }
    }

    /**
     * Resize the list if needed. Marked as final in order to encourage the
     * compiler to inline the code for faster execution
     */
    private final void resizeShaderLogList()
    {
        if((lastShaderLogItem + 1) == shaderLogList.length)
        {
            int old_size = shaderLogList.length;
            int new_size = old_size + SHADERLIST_INCREMENT;

            ShaderSourceRenderable[] tmp_nodes =
                new ShaderSourceRenderable[new_size];

            System.arraycopy(shaderLogList, 0, tmp_nodes, 0, old_size);

            shaderLogList = tmp_nodes;
        }
    }
}
