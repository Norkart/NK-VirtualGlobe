/*****************************************************************************
 *                        Web3d.org Copyright (c) 2001 - 2006
 *                               Java Source
 *
 * This source is licensed under the GNU LGPL v2.1
 * Please read http://www.gnu.org/copyleft/lgpl.html for more information
 *
 * This software comes with the standard NO WARRANTY disclaimer for any
 * purpose. Use it at your own risk. If there's a problem you get to fix it.
 *
 ****************************************************************************/
package org.web3d.vrml.renderer;

// External imports
import java.util.*;

import java.io.Reader;
import java.io.StringReader;
import java.io.IOException;

// Local imports
import org.web3d.vrml.lang.*;
import org.web3d.vrml.nodes.*;

import org.web3d.util.DefaultErrorReporter;
import org.web3d.util.ErrorReporter;
import org.web3d.util.IntHashMap;
import org.web3d.vrml.nodes.VRMLNodeType;
import org.web3d.vrml.nodes.VRMLFieldData;
import org.web3d.vrml.nodes.proto.ProtoFieldInfo;
import org.web3d.vrml.nodes.proto.ProtoScene;
import org.web3d.vrml.parser.FieldParserFactory;
import org.web3d.vrml.parser.VRMLFieldReader;

/**
 * A concrete instance of a Prototype that is common for all renderers.
 *<p>
 *
 * This class cannot be instantiated directly. The only way to get an instance
 * of this is to ask for one from a proto implementation - either external or
 * normal. As a node that does not form part of the scenegraph, the fields
 * that are those of the root node's definition. If you ask for the normal
 * implementation node, you will also get this first node.
 * <p>
 *
 * <b>IS Implementation</b>
 * <p>
 * This implementation handles IS values as a sort of route with a few missing
 * bits. When a value is set in the interface declaration, we look up all the
 * IS related nodes and fields. For each of these we then call
 * <code>sendRoute()</code> on them to update their value.
 * <p>
 * For the reverse case, when a value changes inside the proto body, we just
 * mark the field as being changed in that node. Then, when someone checks the
 * proto interface field, it will go through the list of related IS nodes and
 * ask their field if it has been updated. If it has, then this value is
 * copied to the interface declaration field and, using <code>setValue()</code>
 * call on the interface field, makes sure it gets propogated to the other
 * users.
 * <p>
 * <b>Note:</b> The upshot of this implementation is that is does not correctly
 * deal with IS values where the end user has not connected a ROUTE to one of
 * the proto declaration fields. In order to send values to items where there
 * is an IS, we rely on having the user call <code>hasFieldChanged()</code>
 * or <code>setValue()</code> to update all the internal users of the field.
 * In the case where fields are not routed, this means that
 * <code>hasFieldChanged()</code> is never called and hence the other users of
 * IS are never informed.
 * <p>
 *
 * <b>DEF/USE Handling</b>
 * <p>
 *
 * Because you can DEF an instance of a Proto, we run into all sorts of
 * interesting problems. As we have to put in Java3D shared groups and stuff
 * we really need access to the root node before it is created. The problem
 * there is that we don't have that access, and even when we do it is too late
 * to deal with the DEF work. In an ideal world, when you ask for the
 * implementation node the J3D node it returns and the node this instance
 * returns are going to be the same thing. DEF completely stuffs with that
 * idea.
 * <p>
 * The solution implemented here is to take the root node and apply any
 * wrapping that may be needed to get it to work in a shared environment. In
 * order to use a ProtoInstance within the J3D scene you first check for the
 * type being correct by asking for the Implementation node and checking the
 * interface corresponds to one that you are allowed to accept. If that
 * passes then you check for the DEF with isDEF() just like any other node.
 * Then, to add the real object to the scenegraph you call either
 * getSharedObject() or getSceneGraphObject() as appropriate. Note that they
 * must be called on this class instance, not on the implementation node. If
 * you call them on the implementation instance, the results are undefined and
 * will probably lead to a lot of errors generated by the Java3D internals.
 *
 *
 * @author Justin Couch
 * @version $Revision: 1.75 $
 */
public class CRProtoInstance
    implements VRMLProtoInstance, VRMLNodeType {

    /** Constant indicating a field of size 0 */
    private static final Integer ZERO_SIZE = new Integer(0);

    /** Constant indicating a field of size 1 */
    private static final Integer SINGLE_SIZE = new Integer(1);

    /** Prefix allowed for exposedFields names */
    private static final String SET_PREFIX = "set_";

    /** Suffix allowed for exposedFields names */
    private static final String CHANGE_SUFFIX = "_changed";

    /**
     * A standard message for when the supplied node is wrong. Just add the
     * node name of the wrong type to the end.
     */
    protected static final String BAD_NODE_MSG =
        "The supplied node cannot be copied as it's type is wrong. The type " +
        "supplied is ";

    /** Message for when the proto is not a Metadata */
    protected static final String METADATA_PROTO_MSG =
        "Proto does not describe a Metadata object";

    /** Message for when the node in setValue() is not a Metadata */
    protected static final String METADATA_NODE_MSG =
        "Node does not describe a Metadata object";

    /** Message when the field type is not valid in VRML97 */
    protected static final String VRML97_FIELD_MSG =
        "Field type not supported in VRML97: ";

    /** When the same field is defined twice, but with different types */
    protected static final String FIELD_CLASH_MSG = "The same field has been " +
        "declared twice in this node, but the data types or access types are " +
        "different.";

    /**
     * Message when the reference count attempts to decrement a layer ID that
     * does not currently refrence this node. Under correct implementation,
     * this message should never be seen.
     */
    private static final String NO_LAYER_REF_MSG =
        "An attempt was made to decrement a reference count to a layer that " +
        "is not currently referencing this node. Layer ID is ";

    /** Reporter instance for handing out errors */
    protected ErrorReporter errorReporter;

    // References to some useful variables.

    /** Flag for the node being static */
    protected boolean isStatic;

    /** The major version of the spec this instance belongs to. */
    protected int vrmlMajorVersion;

    /** The minor version of the spec this instance belongs to. */
    protected int vrmlMinorVersion;

    /** Data mapping holding the field name -> index (Integer) mapping */
    protected Map fieldIndexMap;

    /** Unique version of fieldIndexMap with no exposedField expansions */
    protected Map uniqueFieldIndexMap;

    /**
     * List of the field maps registered in order for their definitions.
     * When created, this list will have a null value in each index position
     * for the size of the number of declared fields. This allows a user to
     * set(int, object) the value if they want.
     */
    protected List fieldDeclList;

    /** The name of this node type */
    protected final String nodeName;

    /** Index of the metadata field */
    protected final int FIELD_METADATA;

    /** Scratch class var for returning field data */
    protected final VRMLFieldData fieldData;

    /** Mapping of field index to user data object */
    private final IntHashMap userData;

    /** The current listener(s) registered */
    private VRMLNodeListener nodeListener;

    /** The nodes that form the body group */
    protected VRMLNodeType[] bodyNodes;

    /** A counter for the number of body nodes */
    protected int bodyNodeCount;

    /** The node that describes the type of proto */
    protected VRMLNodeType rootNode;

    /** Contained scene information */
    protected ProtoScene sceneInfo;

    /** Frame state manager for this event model instance */
    protected FrameStateManager stateManager;

    /** Mapping of an external imported name to the ImportNodeProxy instance */
    protected HashMap proxyNodeMap;

    /**
     * The mapping that holds is field index (key) to the list of destination
     * node information. (ProtoFieldInfo - value).
     */
    protected final IntHashMap isMap;

    /**
     * A map of the field indexes (Integer) to their values (object). Fields
     * using primitive types have these converted to the equivalent Class.
     */
    protected final IntHashMap fieldValueMap;

    /**
     * A map of the field indexes (Integer) to the size of the data provided
     * at that field. Used for multi-value fields and represents the number of
     * elements, not the number of raw values.
     */
    protected final IntHashMap fieldSizeMap;

    /** Map of whether the field index has been changed since last check */
    protected final IntHashMap fieldChangedMap;

    /** Flag indicating this is a DEF node */
    protected boolean isDEF;

    /** Flag indicating we are in setup mode currently */
    protected boolean inSetup;

    /** Flag indicating VRML97 lookup semantics for IS behaviour */
    protected boolean isVrml97;

    /** Flad indicating we should ignore setValues that overwrite values */
    private boolean backFill;

    /** The last field index.  Used for extern protos that append fields */
    protected int lastFieldIndex;

    /** IsList entry to use for sendRoute, the one that triggered the event */
    protected int[] isListEntry;

    /**
     * The current number of references to this node. This is for informational
     * purposes only and should never be touched by derived classes.
     */
    protected int[] refCounts;

    /**
     * The list of layer IDs that reference this node. Should correspond 1:1
     * to the counts in {@link #refCounts}. If none, this is null.
     */
    protected int[] layerIds;

    /** The list of IDs that have been marked as being removed. */
    protected int[] removedLayerIds;

    /** The secondary type of this proto instance */
    private int[] secondaryType;

    /** Whether the protoBody is complete */
    protected boolean completeBody;

    /** A list map of field indexes to lost externProtoLoaded events */
    private IntHashMap lostList;

    /** Flag for when the scene is set before the frame state manager*/
    private boolean delayedAdd;

    /** Prevents double calls to propogateSetupFinish for externprotos */
    private boolean propogated;

    /**
     * Flag for dealing with fire field changed calls based on exposedFields
     * and IS.
     */
    private boolean exposedEvent;

    /** Indices of the fields that are MFNode or SFnode */
    private int[] nodeFields;

    /** SFNode metadata NULL */
    protected VRMLNodeType vfMetadata;

    /** proto representation of the metadata node */
    protected VRMLProtoInstance pMetadata;

    /** The body nodes have not been counted */
    private boolean bodyNotCounted;

    /** Are we in the middle of resendIS */
    private boolean resendingIS;

    /**
     * Inner class to act as a go-between for a given IS listing on the
     * proto's external field interface and the internal nodes that reference
     * it through IS. Needed so that when a field changes on an internal node
     * and there is a field listener to it externally, the proper notifications
     * will be sent. Without this, notifications would only be sent based on
     * a pull model - when a route is connected or someone attempts to directly
     * read the value. This is used to make the EAI and X3D SAI work correctly.
     *
     * An inner class is used because we need direct access to the nodeListener
     * array and/or call to the fireFieldChanged() method.
     */
    private class ISFieldAdapter implements VRMLNodeListener {

        /** The index of the PROTO's IS field */
        private final int isFieldIndex;

        /** Index of the field that we have an IS for in the node */
        private final int sourceIndex;

        /** The node that is the source for this listener */
        private final VRMLNodeType sourceNode;

        /**
         * Construct a new adapter instance connecting the node's source
         * field to this field of the proto interface.
         *
         * @param protoField Index of the field in the proto interface
         * @param node The node that this listener is the source to
         * @param srcField Index of the field in the source body node
         */
        ISFieldAdapter(int protoField, VRMLNodeType node, int srcField) {
            isFieldIndex = protoField;
            sourceIndex = srcField;
            sourceNode = node;
        }

        /**
         * Notification that the field represented by the given index has
         * changed.
         *
         * @param index The index of the field in source node that changed
         */
        public void fieldChanged(int index) {
            if((index != sourceIndex) || exposedEvent)
                return;

            // Update the VRMLFieldData object with the updated
            // field value.
            fieldChangedMap.put(isFieldIndex, Boolean.TRUE);
            VRMLFieldData data = sourceNode.getFieldValue(index);

            Integer curr_size = (Integer)fieldSizeMap.get(isFieldIndex);

            if((curr_size == null) || curr_size.intValue() != data.numElements) {

                VRMLFieldDeclaration decl = getFieldDeclaration(isFieldIndex);

                int size_mult = decl.getFieldSize();

                fieldSizeMap.put(isFieldIndex,
                                 new Integer(data.numElements * size_mult));
            }

            switch(data.dataType) {
                case VRMLFieldData.BOOLEAN_DATA:
                    fieldValueMap.put(isFieldIndex,
                                      Boolean.valueOf(data.booleanValue));
                    break;

                case VRMLFieldData.INT_DATA:
                    fieldValueMap.put(isFieldIndex,
                                      new Integer(data.intValue));
                    break;

                case VRMLFieldData.LONG_DATA:
                    fieldValueMap.put(isFieldIndex,
                                      new Long(data.longValue));
                    break;

                case VRMLFieldData.FLOAT_DATA:
                    fieldValueMap.put(isFieldIndex,
                                      new Float(data.floatValue));
                    break;

                case VRMLFieldData.DOUBLE_DATA:
                    fieldValueMap.put(isFieldIndex,
                                      new Double(data.doubleValue));
                    break;

                case VRMLFieldData.STRING_DATA:
                    fieldValueMap.put(isFieldIndex, data.stringValue);
                    break;

                case VRMLFieldData.NODE_DATA:
                    fieldValueMap.put(isFieldIndex, data.nodeValue);
                    break;

                case VRMLFieldData.BOOLEAN_ARRAY_DATA:
                    fieldValueMap.put(isFieldIndex, data.booleanArrayValue);
                    break;

                case VRMLFieldData.INT_ARRAY_DATA:
                    fieldValueMap.put(isFieldIndex, data.intArrayValue);
                    break;

                case VRMLFieldData.LONG_ARRAY_DATA:
                    fieldValueMap.put(isFieldIndex, data.longArrayValue);
                    break;

                case VRMLFieldData.FLOAT_ARRAY_DATA:
                    fieldValueMap.put(isFieldIndex, data.floatArrayValue);
                    break;

                case VRMLFieldData.DOUBLE_ARRAY_DATA:
                    fieldValueMap.put(isFieldIndex, data.doubleArrayValue);
                    break;

                case VRMLFieldData.NODE_ARRAY_DATA:
                    fieldValueMap.put(isFieldIndex, data.nodeArrayValue);
                    break;

                case VRMLFieldData.STRING_ARRAY_DATA:
                    fieldValueMap.put(isFieldIndex, data.stringArrayValue);
                    break;

                default:
                    System.out.println("WAAAAAAH! Unknown data type to copy!");
            }

            fireFieldChanged(isFieldIndex);

        }
    }

    /**
     * Create an instance for the proto with the number of fields. To set the
     * values of these fields, use the normal setValue methods. The fields are
     * list does not care if it contains null values.
     *
     * @param name The node name of the proto
     * @param vrml97 true if this is a VRML97 issue proto
     * @param fields The fields that need to be set here
     * @param numBodyNodes The number of nodes in the body of the proto
     */
    protected CRProtoInstance(String name,
                              boolean vrml97,
                              VRMLFieldDeclaration[] fields,
                              int numBodyNodes) {
        nodeName = name;
        lastFieldIndex = fields.length;
        isVrml97 = vrml97;

        secondaryType = TypeConstants.NO_SECONDARY_TYPE;
        propogated = false;
        bodyNotCounted = false;
        resendingIS = false;

        errorReporter = DefaultErrorReporter.getDefaultReporter();

        fieldIndexMap = new HashMap(lastFieldIndex, 1.0f);
        uniqueFieldIndexMap = new HashMap(lastFieldIndex, 1.0f);
        fieldDeclList = new ArrayList(lastFieldIndex);
        userData = new IntHashMap(lastFieldIndex);

        bodyNodes = new VRMLNodeType[numBodyNodes];
        fieldData =  new VRMLFieldData();

        for(int i = 0; i < fields.length; i++) {
            fieldDeclList.add(fields[i]);

            if(fields[i] != null) {
                String field_name = fields[i].getName();
                Integer index = new Integer(i);

                fieldIndexMap.put(field_name, index);
                uniqueFieldIndexMap.put(field_name, index);

                // special case exposedFields because they are allowed to have
                // alternate names.
                if(fields[i].getAccessType() == FieldConstants.EXPOSEDFIELD) {
                    if(!field_name.startsWith(SET_PREFIX))
                        fieldIndexMap.put(SET_PREFIX + field_name, index);

                    if(!field_name.endsWith(CHANGE_SUFFIX))
                        fieldIndexMap.put(field_name + CHANGE_SUFFIX, index);
                }
            }
        }

        isDEF = false;
        inSetup = true;
        backFill = false;
        isMap = new IntHashMap(fields.length);
        fieldValueMap = new IntHashMap(fields.length);
        fieldSizeMap = new IntHashMap(fields.length);
        fieldChangedMap = new IntHashMap(fields.length);
        completeBody = false;
        lostList = new IntHashMap();
        proxyNodeMap = new HashMap();
        delayedAdd = false;
        exposedEvent = false;

        // Look for the index of the metadata field
        FIELD_METADATA = getFieldIndex("metadata");
    }

    //----------------------------------------------------------
    // Methods defined by VRMLProtoInstance
    //----------------------------------------------------------

    /**
     * Get the first node declared in the proto as that defines just how we
     * we can add this into the scenegraph. If this is an empty prototype
     * implementation, or represents an Extern proto that has not been loaded
     * yet then this will return null.
     *
     * @return The node instance that represents the first node
     */
    public VRMLNodeType getImplementationNode() {

        if(!completeBody)
            return null;

        if((rootNode == null) && (bodyNodeCount != 0)) {
            rootNode = bodyNodes[0];

            // time to go looking for the real secondary types. Recurse
            // the definitions until one finds something that is not a proto.
            int body_type = rootNode.getPrimaryType();

            if(body_type == TypeConstants.ProtoInstance)
                secondaryType = rootNode.getSecondaryType();
            else
                secondaryType = new int[] { body_type };
        }

        return rootNode;
    }

    /**
     * Get the list of all the body nodes in this proto instance. Nodes are
     * defined in declaration order. Index 0 is always the same value as
     * that returned by {@link #getImplementationNode()}. This should be called
     * sparingly. It is really only of use to something that needs to traverse
     * the entire scene graph or for scripting to provide access to the root of
     * the scene.
     *
     * @return The list of nodes from the body
     */
    public VRMLNodeType[] getBodyNodes() {
        return bodyNodes;
    }

    //----------------------------------------------------------
    // Methods defined by VRMLNodeType
    //----------------------------------------------------------

    /**
     * Get the count of the number of fields currently registered.
     *
     * @return The number of fields available
     */
    public int getFieldCount() {
        return fieldDeclList.size();
    }

    /**
     * Make a listing of all fields that are currently registered in this
     * node. The list contains instances of
     * {@link org.web3d.vrml.lang.VRMLFieldDeclaration}.
     *
     * @return A list of the current field declarations
     */
    public List getAllFields() {
        return fieldDeclList;
    }

    /**
     * Ask for the current number of references to this object in the given
     * layer. If this node represents a layer node itself, then the value
     * returned for that ID should always be one. If the layer requested does
     * not have a reference to this node, return zero.
     *
     * @param layer The id of the layer to get the ref count for
     * @return The number of references to this node
     */
    public int getRefCount(int layer) {
        if(layerIds == null)
            return 0;

        int ret_val = 0;

        for(int i = 0; i < layerIds.length; i++) {
            if(layerIds[i] == layer) {
                ret_val = refCounts[i];
                break;
            }
        }

        return ret_val;
    }

    /**
     * Change the reference count up or down by one for a given layer ID.
     * If there is no reference to the given layer ID previously, add one
     * now. A listing of the layer IDs that reference this node can be
     * retrieved through {@link #getLayerIds()}.
     *
     * @param layer The id of the layer to modify the ref count on
     * @param add true to increment the reference count, false to decrement
     */
    public synchronized void updateRefCount(int layer, boolean add) {
        // Go looking for the layer first to see if we have it.
        if(layerIds != null) {
            int ref_idx = -1;

            for(int i = 0; i < layerIds.length; i++) {
                if(layerIds[i] == layer) {
                    ref_idx = i;
                    break;
                }
            }

            if(ref_idx == -1) {
                // Decrementing a layer Id that doesn't exist? Something is
                // badly wrong, so let's toss an exception and debug WTF just
                // happened.
                if(!add)
                    throw new IllegalStateException(NO_LAYER_REF_MSG + layer);

                int[] tmp = new int[layerIds.length + 1];
                System.arraycopy(layerIds, 0, tmp, 0, layerIds.length);
                tmp[layerIds.length] = layer;
                layerIds = tmp;

                tmp = new int[refCounts.length + 1];
                System.arraycopy(refCounts, 0, tmp, 0, refCounts.length);
                tmp[refCounts.length] = 1;
                refCounts = tmp;

                // Check the removed layer ID list ot make sure that we don't
                // have this layer on the list. If so, remove it.
                int size = removedLayerIds == null ? 0 : removedLayerIds.length;

                for(int i = 0; i < size; i++) {
                    if(removedLayerIds[i] != layer)
                        continue;

                    if(size == 1) {
                        removedLayerIds = null;
                    } else {
                        int[] tmp1 = new int[size - 1];
                        System.arraycopy(removedLayerIds, 0, tmp1, 0, i - 1);
                        System.arraycopy(removedLayerIds,
                                         i + 1,
                                         tmp1,
                                         i,
                                         size - i - 1);
                        removedLayerIds = tmp1;
                    }
                }
            } else {
                if(add) {
                    refCounts[ref_idx]++;
                } else {
                    refCounts[ref_idx]--;

                    if(refCounts[ref_idx] <= 0) {
                        int[] tmp1 = new int[refCounts.length - 1];
                        int[] tmp2 = new int[refCounts.length - 1];

                        for(int i = 0; i < ref_idx; i++) {
                            tmp1[i] = refCounts[i];
                            tmp2[i] = layerIds[i];
                        }

                        for(int i = ref_idx + 1; i < refCounts.length; i++) {
                            tmp1[i - 1] = refCounts[i];
                            tmp2[i - 1] = layerIds[i];
                        }

                        refCounts = tmp1;
                        layerIds = tmp2;

                        if(removedLayerIds == null) {
                            removedLayerIds = new int[] { layer } ;
                        } else {
                            int[] tmp3 = new int[removedLayerIds.length + 1];
                            System.arraycopy(removedLayerIds,
                                             0,
                                             tmp3,
                                             0,
                                             removedLayerIds.length);
                            removedLayerIds = tmp3;
                        }
                    }


                    // Do we have no references left?
                    if(refCounts.length == 1 && refCounts[0] == 0) {
                        refCounts = null;
                        layerIds = null;
                    }
                }
            }
        } else {
            if(!add)
                throw new IllegalStateException(NO_LAYER_REF_MSG + layer);

            layerIds = new int[] { layer };
            refCounts = new int[] { 1 };
        }

        if (bodyNodes.length == 0) {
            bodyNotCounted = true;
        } else {
            // Perform the same operation on all body nodes
            for(int j = 0; j < bodyNodes.length; j++) {
                bodyNodes[j].updateRefCount(layer, add);
            }
        }
    }

    /**
     * Get a listing of the current layer IDs that are directly or indirectly
     * referencing this node. If this layer is not part of a live scene graph
     * (eg held by a script code, but not by the script itself) then this will
     * will return a null value. The array will always be exactly equal in
     * length to the number of IDs that reference this node.
     *
     * @return An array of all the IDs referencing this node or null if none
     */
    public int[] getLayerIds() {
        return layerIds;
    }


    /**
     * Get the list of layer IDs that this node has just been removed from.
     * If it currently has not been removed from anything, this will return
     * null. This will remain updated until the next
     * {@link #clearRemovedLayerIds()} call.
     *
     * @return An array of all the IDs this is delete from or null if none
     */
    public int[] getRemovedLayerIds() {
        return removedLayerIds;
    }


    /**
     * Clear the current removed layer ID list. If there is nothing removed,
     * this method does nothing.
     */
    public void clearRemovedLayerIds() {
        removedLayerIds = null;
    }

    /**
     * Set the X3DMetadataObject that is associated with this node.
     *
     * @param data The node to register as the metadata
     * @throws InvalidFieldValueException The object instance provided
     *     does not implment VRMLMetadataNodeType or is not a proto instance
     *     that encapsulates it as it's primary type
     */
    public void setMetadataObject(VRMLNodeType data)
        throws InvalidFieldValueException {

        if(data == null) {
            fieldValueMap.put(FIELD_METADATA, null);
        } else {
            // check for the right interface
            if(data instanceof VRMLMetadataObjectNodeType) {
                fieldValueMap.put(FIELD_METADATA, data);
            } else if(data instanceof VRMLProtoInstance) {
                VRMLProtoInstance proto = (VRMLProtoInstance)data;
                VRMLNodeType impl = proto.getImplementationNode();

                if(!(impl instanceof VRMLMetadataObjectNodeType))
                    throw new InvalidFieldValueException(METADATA_PROTO_MSG);

                fieldValueMap.put(FIELD_METADATA, data);
                fieldSizeMap.put(FIELD_METADATA, SINGLE_SIZE);
            } else
                throw new InvalidFieldValueException(METADATA_NODE_MSG);
        }

        if(!inSetup) {
            fieldChangedMap.put(FIELD_METADATA, Boolean.TRUE);
            fireFieldChanged(FIELD_METADATA);
        }
    }

    /**
     * Get the currently registered metadata object instance. If none is set
     * then return null.
     *
     * @return The current metadata object or null
     */
    public VRMLNodeType getMetadataObject() {
        return (VRMLNodeType)fieldValueMap.get(FIELD_METADATA);
    }

    /**
     * Check to see if setupFinished() has already been called on this node.
     *
     * @return true if setupFinished() has been called
     */
    public boolean isSetupFinished() {
        return !inSetup;
    }

    /**
     * Notification that the construction phase of this node has finished.
     * If the node would like to do any internal processing, such as setting
     * up geometry, then go for it now.
     */
    public void setupFinished() {
        if(!inSetup)
            return;

        if (nodeFields == null) {
            // Fill in the nodeFields so others can walk the children before the EP resolves

            // Build the list of MF/SFNode fields for the list.
            int size = fieldDeclList.size();

            // first time through, count the number fields, then loop
            // again to assign.
            VRMLFieldDeclaration decl;
            int type;
            int cnt = 0;
            for(int i = 0; i < size; i++) {
                decl = (VRMLFieldDeclaration)fieldDeclList.get(i);
                type = decl.getFieldType();
                if((type == FieldConstants.MFNODE) ||
                   (type == FieldConstants.SFNODE))
                   cnt++;
            }

            if(cnt == 0)
                return;

            nodeFields = new int[cnt];
            cnt = 0;

            for(int i = 0; i < size; i++) {
                decl = (VRMLFieldDeclaration)fieldDeclList.get(i);
                type = decl.getFieldType();
                if((type == FieldConstants.MFNODE) ||
                   (type == FieldConstants.SFNODE))
                   nodeFields[cnt++] = getFieldIndex(decl.getName());
            }
        }

        if (!completeBody)
            return;

        // Mark this ASAP as sometimes it is possible to have proto instances
        // that end up with cyclic scene graphs that reference themselves.
        // Apart from being extremely dodgy, this is an illegal scene graph
        // structure for the most part (though some people argue that it is
        // not!?) Having this here is a good enough guard most of the time.
        inSetup = false;

        int[] keySet = lostList.keySet();

        ArrayList list;
        for(int i=0; i < keySet.length; i++) {
            list = (ArrayList) lostList.get(keySet[i]);

            for (int k=0; k < list.size(); k++) {
                VRMLNodeType node = (VRMLNodeType) list.get(k);

                // now set the value to all the fields that are ISd
                ProtoFieldInfo[] is_list = (ProtoFieldInfo[])isMap.get(keySet[i]);

                if(is_list != null) {
                    for(int j = 0; j < is_list.length; j++)
                        is_list[j].node.notifyExternProtoLoaded(is_list[j].field, node);
                }
            }

            list.clear();
        }

        lostList.clear();
        lostList = null;

        // Moved from setContainedScene
        if(stateManager == null) {
            delayedAdd = true;
            // TODO: This was still here, why?
            //stateManager.registerAddedScene(this);
        }

        isListEntry = new int[lastFieldIndex];

        propagateSetupFinished();
    }

    /**
     * Set the frame state manager to be used by this proto instance.
     * used to pass in information about the contained scene for extern
     * proto handler.
     *
     * @param mgr The manager instance to use
     */
    public void setFrameStateManager(FrameStateManager mgr) {
        stateManager = mgr;

        if(delayedAdd) {
            stateManager.registerAddedScene(this);
            delayedAdd = false;
        }
    }

    //----------------------------------------------------------
    // Methods defined by FrameStateListener
    //----------------------------------------------------------

    /**
     * Ignored by this implementation.
     */
    public void allEventsComplete() {
    }

    //----------------------------------------------------------
    // Methods defined by VRMLNode
    //----------------------------------------------------------

    /**
     * Register an error reporter with the engine so that any errors generated
     * by the node's internals can be reported in a nice, pretty fashion.
     * Setting a value of null will clear the currently set reporter. If one
     * is already set, the new value replaces the old.
     *
     * @param reporter The instance to use or null
     */
    public void setErrorReporter(ErrorReporter reporter) {
        errorReporter = reporter;

        // Reset the default only if we are not shutting down the system.
        if(reporter == null)
            errorReporter = DefaultErrorReporter.getDefaultReporter();
    }

    /**
     * Get the name of this node as a string.
     *
     * @return The name of the node
     */
    public String getVRMLNodeName() {
        return nodeName;
    }

    /**
     * Set the version of VRML that this node should represent. Different
     * versions have different capabilities, even within the same node.
     *
     * @param major The major version number of this scene
     * @param minor The minor version number of this scene
     * @param isStatic true if this node is under a static group and won't
     *    change after the setup is finished
     */
    public void setVersion(int major, int minor, boolean isStatic) {
        vrmlMajorVersion = major;
        vrmlMinorVersion = minor;
        this.isStatic = isStatic;
    }

    /**
     * Notify this node that is has been DEFd. This method shall only be
     * called before setupFinished(). It is an error to call it any other
     * time. It is also guaranteed that this call will be made after
     * construction, but before any of the setValue() methods have been called.
     *
     * @throws IllegalStateException The setup is finished.
     */
    public void setDEF() {
        if(!inSetup)
            throw new IllegalStateException("Can't set DEF now");

        isDEF = true;
    }

    /**
     * Check to see if this node has been DEFd. Returns true if it has and
     * the user should ask for the shared representation rather than the
     * normal one.
     *
     * @return true if this node has been DEFd
     */
    public boolean isDEF() {
        return isDEF;
    }

    //----------------------------------------------------------
    // Methods defined by VRMLNode
    //----------------------------------------------------------

    /**
     * Get the index of the given field name. If the name does not exist for
     * this node then return a value of -1.
     *
     * @param fieldName The name of the field we want the index from
     * @return The index of the field name or -1
     */
    public int getFieldIndex(String fieldName) {
        Integer index = (Integer)fieldIndexMap.get(fieldName);

        return (index == null) ? -1 : index.intValue();
    }

    /**
     * Get the list of indices that correspond to fields that contain nodes
     * ie MFNode and SFNode). Used for blind scene graph traversal without
     * needing to spend time querying for all fields etc. If a node does
     * not have any fields that contain nodes, this shall return null. The
     * field list covers all field types, regardless of whether they are
     * readable or not at the VRML-level.
     *
     * @return The list of field indices that correspond to SF/MFnode fields
     *    or null if none
     */
    public int[] getNodeFieldIndices() {
        return nodeFields;
    }

    /**
     * Get the declaration of the field at the given index. This allows for
     * reverse lookup if needed. If the field does not exist, this will give
     * a value of null.
     *
     * @param index The index of the field to get information
     * @return A representation of this field's information
     */
    public VRMLFieldDeclaration getFieldDeclaration(int index) {
        return (VRMLFieldDeclaration)fieldDeclList.get(index);
    }

    /**
     * Get the number of fields defined for this node.
     *
     * @return The number of fields.
     */
    public int getNumFields() {
        return fieldDeclList.size();
    }

    /**
     * Add a listener to this node instance. If the listener is already added
     * or null the request is silently ignored.
     *
     * @param l The listener instance to add
     */
    public void addNodeListener(VRMLNodeListener l) {
        nodeListener = NodeListenerMulticaster.add(nodeListener, l);
    }

    /**
     * Remove a listener from this node instance. If the listener is null or
     * not registered, the request is silently ignored.
     *
     * @param l The listener to be removed
     */
    public void removeNodeListener(VRMLNodeListener l) {
        nodeListener = NodeListenerMulticaster.remove(nodeListener, l);
    }

    /**
     * Check to see if the given field has changed since we last checked.
     * Calling this method will set the flag back to "not changed" so that two
     * consective reads after a changed value would result in a true and then
     * false being returned. If the field number is not recognized for this
     * node then this returns false.
     * <p>
     * For a proto instance, we have to check the IS values and so look at
     * every output node that has output mapped back to this field. We never
     * keep a local flag of the fields stored here.
     *
     * @param index The index of the field to change.
     * @return true if the field has changed since last read
     */
    public boolean hasFieldChanged(int index) {

        if(inSetup)
           return false;

        boolean ret_val = false;
        Boolean changed = (Boolean)fieldChangedMap.get(index);

        if(changed != null) {
            ret_val = changed.booleanValue();
            // set it back to false now we've read it
            if(ret_val)
                fieldChangedMap.put(index, Boolean.FALSE);
        }

        return ret_val;
    }

    /**
     * Get the value of a field. If the field is a primitive type, it will
     * return a class representing the value. For arrays or nodes it will
     * return the instance directly.
     *
     * @param index The index of the field to change.
     * @return The class representing the field value
     * @throws InvalidFieldException The field index is not known
     */
    public VRMLFieldData getFieldValue(int index) throws InvalidFieldException {

        VRMLFieldDeclaration decl = getFieldDeclaration(index);

        if(decl == null)
            throw new InvalidFieldException(nodeName, index);

        Object value = fieldValueMap.get(index);
        Integer size = (Integer)fieldSizeMap.get(index);

        fieldData.numElements = (size != null) ? size.intValue(): 0;

        switch(decl.getFieldType()) {
            case FieldConstants.SFINT32:
                fieldData.intValue =
                    (value == null) ? 0 : ((Integer)value).intValue();
                fieldData.dataType = VRMLFieldData.INT_DATA;
                break;

            case FieldConstants.MFINT32:
                fieldData.intArrayValue = (int[])value;
                fieldData.dataType = VRMLFieldData.INT_ARRAY_DATA;
                break;

            case FieldConstants.SFFLOAT:
                fieldData.floatValue =
                    (value == null) ? 0 : ((Float)value).floatValue();
                fieldData.dataType = VRMLFieldData.FLOAT_DATA;
                break;

            case FieldConstants.MFFLOAT:
                fieldData.floatArrayValue = (float[])value;
                fieldData.dataType = VRMLFieldData.FLOAT_ARRAY_DATA;
                break;

            case FieldConstants.SFDOUBLE:
                fieldData.doubleValue =
                    (value == null) ? 0 : ((Double)value).doubleValue();
                fieldData.dataType = VRMLFieldData.DOUBLE_DATA;
                break;

            case FieldConstants.MFDOUBLE:
                fieldData.doubleArrayValue = (double[])value;
                fieldData.dataType = VRMLFieldData.DOUBLE_ARRAY_DATA;
                break;

            case FieldConstants.SFLONG:
                fieldData.longValue =
                    (value == null) ? 0 : ((Long)value).longValue();
                fieldData.dataType = VRMLFieldData.LONG_DATA;
                break;

            case FieldConstants.MFLONG:
                fieldData.longArrayValue = (long[])value;
                fieldData.dataType = VRMLFieldData.LONG_ARRAY_DATA;
                break;

            case FieldConstants.SFBOOL:
                fieldData.booleanValue =
                    (value == null) ? false : ((Boolean)value).booleanValue();
                fieldData.dataType = VRMLFieldData.BOOLEAN_DATA;
                break;

            case FieldConstants.MFBOOL:
                fieldData.booleanArrayValue = (boolean[])value;
                fieldData.dataType = VRMLFieldData.BOOLEAN_ARRAY_DATA;
                break;

            case FieldConstants.SFTIME:
                fieldData.doubleValue =
                    (value == null) ? -1 : ((Double)value).doubleValue();
                fieldData.dataType = VRMLFieldData.DOUBLE_DATA;
                break;

            case FieldConstants.MFTIME:
                fieldData.doubleArrayValue = (double[])value;
                fieldData.dataType = VRMLFieldData.DOUBLE_ARRAY_DATA;
                break;

            case FieldConstants.SFSTRING:
                fieldData.stringValue = (String)value;
                fieldData.dataType = VRMLFieldData.STRING_DATA;
                break;

            case FieldConstants.MFSTRING:
                if (value instanceof String[]) {
                    fieldData.stringArrayValue = (String[])value;
                    fieldData.dataType = VRMLFieldData.STRING_ARRAY_DATA;
                }
                else {
                    fieldData.stringValue = (String)value;
                    fieldData.dataType = VRMLFieldData.STRING_DATA;
                }
                break;

            case FieldConstants.SFNODE:
                fieldData.nodeValue = (VRMLNodeType)value;
                fieldData.dataType = VRMLFieldData.NODE_DATA;
                break;

            case FieldConstants.MFNODE:
                // An mfnode may be a single or array object
                if(value instanceof VRMLNodeType) {
                    fieldData.nodeArrayValue = new VRMLNodeType[1];
                    fieldData.nodeArrayValue[0] = (VRMLNodeType)value;
                } else {
                    fieldData.nodeArrayValue = (VRMLNodeType[])value;
                }

                fieldData.dataType = VRMLFieldData.NODE_ARRAY_DATA;
                break;

            case FieldConstants.SFVEC2F:
            case FieldConstants.MFVEC2F:
                fieldData.floatArrayValue = (float[])value;
                fieldData.dataType = VRMLFieldData.FLOAT_ARRAY_DATA;
                fieldData.numElements /= 2;
                break;

            case FieldConstants.SFVEC2D:
            case FieldConstants.MFVEC2D:
            	fieldData.doubleArrayValue = (double[])value;
            	fieldData.dataType = VRMLFieldData.DOUBLE_ARRAY_DATA;
            	fieldData.numElements /= 2;
            	break;
                
            case FieldConstants.SFCOLOR:
            case FieldConstants.SFVEC3F:
            case FieldConstants.MFCOLOR:
            case FieldConstants.MFVEC3F:
                fieldData.floatArrayValue = (float[])value;
                fieldData.dataType = VRMLFieldData.FLOAT_ARRAY_DATA;
                fieldData.numElements /= 3;
                break;

            case FieldConstants.SFROTATION:
            case FieldConstants.SFCOLORRGBA:
            case FieldConstants.MFROTATION:
            case FieldConstants.MFCOLORRGBA:
            case FieldConstants.MFVEC4F:
            case FieldConstants.SFVEC4F:
                fieldData.floatArrayValue = (float[])value;
                fieldData.dataType = VRMLFieldData.FLOAT_ARRAY_DATA;
                fieldData.numElements /= 4;
                break;

            case FieldConstants.SFVEC3D:
            case FieldConstants.MFVEC3D:
                fieldData.doubleArrayValue = (double[])value;
                fieldData.dataType = VRMLFieldData.DOUBLE_ARRAY_DATA;
                fieldData.numElements /= 3;
                break;

            case FieldConstants.SFVEC4D:
            case FieldConstants.MFVEC4D:
                fieldData.doubleArrayValue = (double[])value;
                fieldData.dataType = VRMLFieldData.DOUBLE_ARRAY_DATA;
                fieldData.numElements /= 4;
                break;

            case FieldConstants.SFMATRIX3F:
            case FieldConstants.MFMATRIX3F:
                fieldData.floatArrayValue = (float[])value;
                fieldData.dataType = VRMLFieldData.FLOAT_ARRAY_DATA;
                fieldData.numElements /= 9;
                break;

            case FieldConstants.SFMATRIX3D:
            case FieldConstants.MFMATRIX3D:
                fieldData.doubleArrayValue = (double[])value;
                fieldData.dataType = VRMLFieldData.DOUBLE_ARRAY_DATA;
                fieldData.numElements /= 9;
                break;

            case FieldConstants.SFMATRIX4F:
            case FieldConstants.MFMATRIX4F:
                fieldData.floatArrayValue = (float[])value;
                fieldData.dataType = VRMLFieldData.FLOAT_ARRAY_DATA;
                fieldData.numElements /= 16;
                break;

            case FieldConstants.SFMATRIX4D:
            case FieldConstants.MFMATRIX4D:
                fieldData.doubleArrayValue = (double[])value;
                fieldData.dataType = VRMLFieldData.DOUBLE_ARRAY_DATA;
                fieldData.numElements /= 16;
                break;

            case FieldConstants.SFIMAGE:
            case FieldConstants.MFIMAGE:
                fieldData.intArrayValue = (int[])value;
                fieldData.dataType = VRMLFieldData.INT_ARRAY_DATA;
                break;
        }

        return fieldData;
    }

    /**
     * Get the primary type of this node.  Replaces the instanceof mechanism
     * for use in switch statements.
     *
     * @return The primary type
     */
    public int getPrimaryType() {
        return TypeConstants.ProtoInstance;
    }

    /**
     * Get the secondary type of this node.  Replaces the instanceof mechanism
     * for use in switch statements. For protos, the secondary type is
     * described as the primary type of the defining node type.
     *
     * @return The secondary type
     */
    public int[] getSecondaryType() {
        return secondaryType;
    }

    /**
     * Notify a node that an ExternProto has resolved.  This will verify the objects
     * type and add it to the render sceneGraph.
     *
     * @param index The field index
     * @throws InvalidFieldValueException If the proto contains he wrong type
     */
     public void notifyExternProtoLoaded(int index, VRMLNodeType node)
        throws InvalidFieldValueException {

        if (inSetup) {
            ArrayList list = (ArrayList) lostList.get(index);

            if (list == null) {
                list = new ArrayList();
                list.add(node);
                lostList.put(index, list);
            } else {
                list.add(node);
            }

            return;
        }

        // now set the value to all the fields that are ISd
        ProtoFieldInfo[] is_list = (ProtoFieldInfo[])isMap.get(index);

        if(is_list == null)
            return;

        for(int i = 0; i < is_list.length; i++)
            is_list[i].node.notifyExternProtoLoaded(is_list[i].field, node);
     }

    /**
     * Send a routed value from this node to the given destination node. The
     * route should use the appropriate setValue() method of the destination
     * node. It should not attempt to cast the node up to a higher level.
     * Routing should also follow the standard rules for the loop breaking and
     * other appropriate rules for the specification.
     *
     * @param time The time that this route occurred (not necessarily epoch
     *   time. Should be treated as a relative value only)
     * @param srcIndex The index of the field in this node that the value
     *   should be sent from
     * @param destNode The node reference that we will be sending the value to
     * @param destIndex The index of the field in the destination node that
     *   the value should be sent to.
     */
    public void sendRoute(double time,
                          int srcIndex,
                          VRMLNodeType destNode,
                          int destIndex) {

        Object value = fieldValueMap.get(srcIndex);
        // need a last sent time here for loop breaking.
        // check the value types. This is nasty....

        if(value == null) {

            int idx = isListEntry[srcIndex];
            // Look for IS relationships
            ProtoFieldInfo[] is_list = (ProtoFieldInfo[])isMap.get(srcIndex);

            if(is_list != null) {
                // Need to know which one changed
                VRMLFieldData val = is_list[isListEntry[idx]].node.getFieldValue(is_list[idx].field);
                switch(val.dataType) {
                    case VRMLFieldData.BOOLEAN_DATA:
                        destNode.setValue(destIndex, val.booleanValue);
                        break;

                    case VRMLFieldData.BOOLEAN_ARRAY_DATA:
                        destNode.setValue(destIndex,
                                          val.booleanArrayValue,
                                          val.numElements);
                        break;

                    case VRMLFieldData.INT_DATA:
                        destNode.setValue(destIndex, val.intValue);
                        break;

                    case VRMLFieldData.INT_ARRAY_DATA:
                        destNode.setValue(destIndex,
                                          val.intArrayValue,
                                          val.numElements);
                        break;

                    case VRMLFieldData.LONG_DATA:
                        destNode.setValue(destIndex, val.longValue);
                        break;

                    case VRMLFieldData.LONG_ARRAY_DATA:
                        destNode.setValue(destIndex,
                                          val.longArrayValue,
                                          val.numElements);
                        break;

                    case VRMLFieldData.FLOAT_DATA:
                        destNode.setValue(destIndex, val.floatValue);
                        break;

                    case VRMLFieldData.FLOAT_ARRAY_DATA:
// TODO:
// not the right size. Should multiply by the raw data size
                        destNode.setValue(destIndex,
                                          val.floatArrayValue,
                                          val.numElements);
                        break;

                    case VRMLFieldData.DOUBLE_DATA:
                        destNode.setValue(destIndex, val.doubleValue);
                        break;

                    case VRMLFieldData.DOUBLE_ARRAY_DATA:
// TODO:
// Not the right size. Should multiply by the raw data size
                        destNode.setValue(destIndex,
                                          val.doubleArrayValue,
                                          val.numElements);
                        break;

                    case VRMLFieldData.STRING_DATA:
                        destNode.setValue(destIndex, val.stringValue);
                        break;

                    case VRMLFieldData.STRING_ARRAY_DATA:
                        destNode.setValue(destIndex,
                                          val.stringArrayValue,
                                          val.numElements);
                        break;

                    case VRMLFieldData.NODE_DATA:
                        destNode.setValue(destIndex, (VRMLNodeType)val.nodeValue);
                        break;

                    case VRMLFieldData.NODE_ARRAY_DATA:
                        destNode.setValue(destIndex,
                                          (VRMLNodeType[])val.nodeArrayValue,
                                          val.numElements);
                        break;
                }
            }

            return;
        }

        try {
            Integer size = (Integer)fieldSizeMap.get(srcIndex);
            sendValue(destNode, destIndex, value, size.intValue());
        } catch(InvalidFieldException ife) {
            System.err.println("Route to invalid event: " +
                               ife.getFieldName());
        } catch(InvalidFieldValueException ifve) {
            System.err.println("Route sending out of range values " +
                               ifve.getFieldName());
        }
    }

    /**
     * Set the value of the field at the given index as an integer. This would
     * be used to set SFInt32 field types.
     *
     * @param index The index of destination field to set
     * @param value The new value to use for the node
     * @throws InvalidFieldException The index does not match a known field
     * @throws InvalidFieldValueException The value provided is out of range
     *    for the field type.
     */
    public void setValue(int index, int value)
        throws InvalidFieldException, InvalidFieldValueException {

        // check for a valid index by getting the value of that index....
        if(fieldDeclList.get(index) == null)
            throw new InvalidFieldException("Unknown field index");

        if (backFill) {
            Object old_value = fieldValueMap.get(index);

            if (old_value != null) {
                value = ((Integer)old_value).intValue();
            } else {
                fieldValueMap.put(index, new Integer(value));
                fieldSizeMap.put(index, SINGLE_SIZE);
                fieldChangedMap.put(index, Boolean.TRUE);
                fireFieldChanged(index);
            }
        } else {
            fieldValueMap.put(index, new Integer(value));
            fieldSizeMap.put(index, SINGLE_SIZE);
            fieldChangedMap.put(index, Boolean.TRUE);
            fireFieldChanged(index);
        }

        // now set the value to all the fields that are ISd
        ProtoFieldInfo[] is_list = (ProtoFieldInfo[])isMap.get(index);

        if(is_list == null)
            return;

        exposedEvent = true;

        for(int i = 0; i < is_list.length; i++)
            is_list[i].node.setValue(is_list[i].field, value);

        exposedEvent = false;
    }

    /**
     * Set the value of the field at the given index as an array of integers.
     * This would be used to set MFInt32 field types.
     *
     * @param index The index of destination field to set
     * @param value The new value to use for the node
     * @param numValid The number of valid values to copy from the array
     * @throws InvalidFieldException The index does not match a known field
     * @throws InvalidFieldValueException The value provided is out of range
     *    for the field type.
     */
    public void setValue(int index, int[] value, int numValid)
        throws InvalidFieldException, InvalidFieldValueException {

        // check for a valid index by getting the value of that index....
        if(fieldDeclList.get(index) == null)
            throw new InvalidFieldException("Unknown field index");

        if (backFill) {
            Object old_value = fieldValueMap.get(index);
            if (old_value != null) {
                value = (int[]) old_value;
                numValid = ((Integer)fieldSizeMap.get(index)).intValue();
            } else {
                fieldSizeMap.put(index, new Integer(numValid));
                fieldValueMap.put(index, value);
                fieldChangedMap.put(index, Boolean.TRUE);
                fireFieldChanged(index);
            }
        } else {
            Integer curr_size = (Integer)fieldSizeMap.get(index);
            if(curr_size == null || curr_size.intValue() != numValid)
                fieldSizeMap.put(index, new Integer(numValid));

            fieldValueMap.put(index, value);
            fieldChangedMap.put(index, Boolean.TRUE);
            fireFieldChanged(index);
        }

        // now set the value to all the fields that are ISd
        ProtoFieldInfo[] is_list = (ProtoFieldInfo[])isMap.get(index);

        if(is_list == null)
            return;

        exposedEvent = true;

        for(int i = 0; i < is_list.length; i++)
            is_list[i].node.setValue(is_list[i].field, value, numValid);

        exposedEvent = false;
    }

    /**
     * Set the value of the field at the given index as an integer. This would
     * be used to set SFLong field types.
     *
     * @param index The index of destination field to set
     * @param value The new value to use for the node
     * @throws InvalidFieldException The index does not match a known field
     * @throws InvalidFieldValueException The value provided is out of range
     *    for the field type.
     */
    public void setValue(int index, long value)
        throws InvalidFieldException, InvalidFieldValueException {

        // check for a valid index by getting the value of that index....
        if(fieldDeclList.get(index) == null)
            throw new InvalidFieldException("Unknown field index");

        if (backFill) {
            Object old_value = fieldValueMap.get(index);
            if (old_value != null)
                value = ((Long)old_value).longValue();
            else {
                fieldSizeMap.put(index, SINGLE_SIZE);
                fieldValueMap.put(index, new Long(value));
                fieldChangedMap.put(index, Boolean.TRUE);
                fireFieldChanged(index);
            }
        } else {
            fieldSizeMap.put(index, SINGLE_SIZE);
            fieldValueMap.put(index, new Long(value));
            fieldChangedMap.put(index, Boolean.TRUE);
            fireFieldChanged(index);
        }

        // now set the value to all the fields that are ISd
        ProtoFieldInfo[] is_list = (ProtoFieldInfo[])isMap.get(index);

        if(is_list == null)
            return;

        exposedEvent = true;

        for(int i = 0; i < is_list.length; i++)
            is_list[i].node.setValue(is_list[i].field, value);

        exposedEvent = false;
    }

    /**
     * Set the value of the field at the given index as an array of integers.
     * This would be used to set MFLong field types.
     *
     * @param index The index of destination field to set
     * @param value The new value to use for the node
     * @param numValid The number of valid values to copy from the array
     * @throws InvalidFieldException The index does not match a known field
     * @throws InvalidFieldValueException The value provided is out of range
     *    for the field type.
     */
    public void setValue(int index, long[] value, int numValid)
        throws InvalidFieldException, InvalidFieldValueException {

        // check for a valid index by getting the value of that index....
        if(fieldDeclList.get(index) == null)
            throw new InvalidFieldException("Unknown field index");

        if (backFill) {
            Object old_value = fieldValueMap.get(index);
            if (old_value != null) {
                value = (long[]) old_value;
                numValid = ((Integer)fieldSizeMap.get(index)).intValue();
            } else {
                fieldSizeMap.put(index, new Integer(numValid));
                fieldValueMap.put(index, value);
                fieldChangedMap.put(index, Boolean.TRUE);
                fireFieldChanged(index);
            }
        } else {
            Integer curr_size = (Integer)fieldSizeMap.get(index);
            if(curr_size == null || curr_size.intValue() != numValid)
                fieldSizeMap.put(index, new Integer(numValid));

            fieldValueMap.put(index, value);
            fieldChangedMap.put(index, Boolean.TRUE);
            fireFieldChanged(index);
        }

        // now set the value to all the fields that are ISd
        ProtoFieldInfo[] is_list = (ProtoFieldInfo[])isMap.get(index);

        if(is_list == null)
            return;

        exposedEvent = true;

        for(int i = 0; i < is_list.length; i++)
            is_list[i].node.setValue(is_list[i].field, value, numValid);

        exposedEvent = false;
    }

    /**
     * Set the value of the field at the given index as an boolean. This would
     * be used to set SFBool field types.
     *
     * @param index The index of destination field to set
     * @param value The new value to use for the node
     * @throws InvalidFieldException The field index is not know
     * @throws InvalidFieldValueException The value provided is out of range
     *    for the field type.
     */
    public void setValue(int index, boolean value)
        throws InvalidFieldException, InvalidFieldValueException {

        if(fieldDeclList.get(index) == null)
            throw new InvalidFieldException("Unknown field index");

        if (backFill) {
            Object old_value = fieldValueMap.get(index);
            if (old_value != null)
                value = ((Boolean)old_value).booleanValue();
            else {
                fieldSizeMap.put(index, SINGLE_SIZE);
                fieldValueMap.put(index, Boolean.valueOf(value));
                fieldChangedMap.put(index, Boolean.TRUE);
                fireFieldChanged(index);
            }
        } else {
            fieldSizeMap.put(index, SINGLE_SIZE);
            fieldValueMap.put(index, new Boolean(value));
            fieldChangedMap.put(index, Boolean.TRUE);
            fireFieldChanged(index);
        }

        // now set the value to all the fields that are ISd
        ProtoFieldInfo[] is_list = (ProtoFieldInfo[])isMap.get(index);

        if(is_list == null)
            return;

        exposedEvent = true;

        for(int i = 0; i < is_list.length; i++)
            is_list[i].node.setValue(is_list[i].field, value);

        exposedEvent = false;
    }

    /**
     * Set the value of the field at the given index as an array of booleans.
     * This would be used to set MFBool field types.
     *
     * @param index The index of destination field to set
     * @param value The new value to use for the node
     * @param numValid The number of valid values to copy from the array
     * @throws InvalidFieldException The field index is not know
     * @throws InvalidFieldValueException The value provided is out of range
     *    for the field type.
     */
    public void setValue(int index, boolean[] value, int numValid)
        throws InvalidFieldException, InvalidFieldValueException {

        if(fieldDeclList.get(index) == null)
            throw new InvalidFieldException("Unknown field index");

        if (backFill) {
            Object old_value = fieldValueMap.get(index);
            if (old_value != null) {
                value = (boolean[]) old_value;
                numValid = ((Integer)fieldSizeMap.get(index)).intValue();
            } else {
                fieldSizeMap.put(index, new Integer(numValid));
                fieldValueMap.put(index, value);
                fieldChangedMap.put(index, Boolean.TRUE);
                fireFieldChanged(index);
            }
        } else {
            Integer curr_size = (Integer)fieldSizeMap.get(index);
            if(curr_size == null || curr_size.intValue() != numValid)
                fieldSizeMap.put(index, new Integer(numValid));

            fieldValueMap.put(index, value);
            fieldChangedMap.put(index, Boolean.TRUE);
            fireFieldChanged(index);
        }

        // now set the value to all the fields that are ISd
        ProtoFieldInfo[] is_list = (ProtoFieldInfo[])isMap.get(index);

        if(is_list == null)
            return;

        exposedEvent = true;

        for(int i = 0; i < is_list.length; i++)
            is_list[i].node.setValue(is_list[i].field, value, numValid);

        exposedEvent = false;
    }

    /**
     * Set the value of the field at the given index as a float. This would
     * be used to set SFFloat field types.
     *
     * @param index The index of destination field to set
     * @param value The new value to use for the node
     * @throws InvalidFieldException The index does not match a known field
     * @throws InvalidFieldValueException The value provided is out of range
     *    for the field type.
     */
    public void setValue(int index, float value)
        throws InvalidFieldException, InvalidFieldValueException {

        if(fieldDeclList.get(index) == null)
            throw new InvalidFieldException("Unknown field index");

        if (backFill) {
            Object old_value = fieldValueMap.get(index);
            if (old_value != null)
                value = ((Float)old_value).floatValue();
            else {
                fieldSizeMap.put(index, SINGLE_SIZE);
                fieldValueMap.put(index, new Float(value));
                fieldChangedMap.put(index, Boolean.TRUE);
                fireFieldChanged(index);
            }
        } else {
            fieldSizeMap.put(index, SINGLE_SIZE);
            fieldValueMap.put(index, new Float(value));
            fieldChangedMap.put(index, Boolean.TRUE);
            fireFieldChanged(index);
        }

        // now set the value to all the fields that are ISd
        ProtoFieldInfo[] is_list = (ProtoFieldInfo[])isMap.get(index);

        if(is_list == null)
            return;

        exposedEvent = true;

        for(int i = 0; i < is_list.length; i++)
            is_list[i].node.setValue(is_list[i].field, value);

        exposedEvent = false;
    }

    /**
     * Set the value of the field at the given index as an array of floats.
     * This would be used to set MFFloat, SFVec2f, SFVec3f and SFRotation
     * field types.
     *
     * @param index The index of destination field to set
     * @param value The new value to use for the node
     * @param numValid The number of valid values to copy from the array
     * @throws InvalidFieldException The index does not match a known field
     * @throws InvalidFieldValueException The value provided is out of range
     *    for the field type.
     */
    public void setValue(int index, float[] value, int numValid)
        throws InvalidFieldException, InvalidFieldValueException {

        if(fieldDeclList.get(index) == null)
            throw new InvalidFieldException("Unknown field index");

        if (backFill) {
            Object old_value = fieldValueMap.get(index);

            if (old_value != null) {
                value = (float[]) old_value;

                numValid = ((Integer)fieldSizeMap.get(index)).intValue();
            } else {
                fieldSizeMap.put(index, new Integer(numValid));
                fieldValueMap.put(index, value);
                fieldChangedMap.put(index, Boolean.TRUE);
                fireFieldChanged(index);
            }
        } else {
            Integer curr_size = (Integer)fieldSizeMap.get(index);
            if(curr_size == null || curr_size.intValue() != numValid)
                fieldSizeMap.put(index, new Integer(numValid));

            fieldValueMap.put(index, value);
            fieldChangedMap.put(index, Boolean.TRUE);
            fireFieldChanged(index);
        }

        // now set the value to all the fields that are ISd
        ProtoFieldInfo[] is_list = (ProtoFieldInfo[])isMap.get(index);

        if(is_list == null)
            return;

        exposedEvent = true;

        for(int i = 0; i < is_list.length; i++)
            is_list[i].node.setValue(is_list[i].field, value, numValid);

        exposedEvent = false;
    }

    /**
     * Set the value of the field at the given index as an double. This would
     * be used to set SFDouble field types.
     *
     * @param index The index of destination field to set
     * @param value The new value to use for the node
     * @throws InvalidFieldException The index does not match a known field
     * @throws InvalidFieldValueException The value provided is out of range
     *    for the field type.
     */
    public void setValue(int index, double value)
        throws InvalidFieldException, InvalidFieldValueException {

        if(fieldDeclList.get(index) == null)
            throw new InvalidFieldException("Unknown field index");

        if (backFill) {
            Object old_value = fieldValueMap.get(index);
            if (old_value != null)
                value = ((Double)old_value).doubleValue();
            else {
                fieldSizeMap.put(index, SINGLE_SIZE);
                fieldValueMap.put(index, new Double(value));
                fieldChangedMap.put(index, Boolean.TRUE);
                fireFieldChanged(index);
            }
        } else {
            fieldSizeMap.put(index, SINGLE_SIZE);
            fieldValueMap.put(index, new Double(value));
            fieldChangedMap.put(index, Boolean.TRUE);
            fireFieldChanged(index);
        }

        // now set the value to all the fields that are ISd
        ProtoFieldInfo[] is_list = (ProtoFieldInfo[])isMap.get(index);

        if(is_list == null)
            return;

        exposedEvent = true;

        for(int i = 0; i < is_list.length; i++)
            is_list[i].node.setValue(is_list[i].field, value);

        exposedEvent = false;
    }

    /**
     * Set the value of the field at the given index as an array of doubles.
     * This would be used to set MFDouble, SFVec2d and SFVec3d field types.
     *
     * @param index The index of destination field to set
     * @param value The new value to use for the node
     * @param numValid The number of valid values to copy from the array
     * @throws InvalidFieldException The index does not match a known field
     * @throws InvalidFieldValueException The value provided is out of range
     *    for the field type.
     */
    public void setValue(int index, double[] value, int numValid)
        throws InvalidFieldException, InvalidFieldValueException {

        if(fieldDeclList.get(index) == null)
            throw new InvalidFieldException("Unknown field index");

        if (backFill) {
            Object old_value = fieldValueMap.get(index);
            if (old_value != null) {
                value = (double[]) old_value;
                numValid = ((Integer)fieldSizeMap.get(index)).intValue();
            } else {
                fieldSizeMap.put(index, new Integer(numValid));
                fieldValueMap.put(index, value);
                fieldChangedMap.put(index, Boolean.TRUE);
                fireFieldChanged(index);
            }
        } else {
            Integer curr_size = (Integer)fieldSizeMap.get(index);
            if(curr_size == null || curr_size.intValue() != numValid)
                fieldSizeMap.put(index, new Integer(numValid));

            fieldValueMap.put(index, value);
            fieldChangedMap.put(index, Boolean.TRUE);
            fireFieldChanged(index);
        }

        // now set the value to all the fields that are ISd
        ProtoFieldInfo[] is_list = (ProtoFieldInfo[])isMap.get(index);

        if(is_list == null)
            return;

        exposedEvent = true;

        for(int i = 0; i < is_list.length; i++)
            is_list[i].node.setValue(is_list[i].field, value, numValid);

        exposedEvent = false;
    }

    /**
     * Set the value of the field at the given index as a string. This would
     * be used to set SFString field types.
     *
     * @param index The index of destination field to set
     * @param value The new value to use for the node
     * @throws InvalidFieldException The index does not match a known field
     * @throws InvalidFieldValueException The value provided is out of range
     *    for the field type.
     */
    public void setValue(int index, String value)
        throws InvalidFieldException, InvalidFieldValueException {

        if(fieldDeclList.get(index) == null)
            throw new InvalidFieldException("Unknown field index");

        if (backFill) {
            Object old_value = fieldValueMap.get(index);

            if (old_value != null)
                value = (String) old_value;
            else {
                fieldSizeMap.put(index, SINGLE_SIZE);
                fieldValueMap.put(index, value);
                fieldChangedMap.put(index, Boolean.TRUE);
                fireFieldChanged(index);
            }
        } else {
            fieldSizeMap.put(index, SINGLE_SIZE);
            fieldValueMap.put(index, value);
            fieldChangedMap.put(index, Boolean.TRUE);
            fireFieldChanged(index);
        }

        // now set the value to all the fields that are ISd
        ProtoFieldInfo[] is_list = (ProtoFieldInfo[])isMap.get(index);

        if(is_list == null)
            return;

        exposedEvent = true;

        for(int i = 0; i < is_list.length; i++)
            is_list[i].node.setValue(is_list[i].field, value);

        exposedEvent = false;
    }

    /**
     * Set the value of the field at the given index as an array of strings.
     * This would be used to set MFString field types.
     *
     * @param index The index of destination field to set
     * @param value The new value to use for the node
     * @param numValid The number of valid values to copy from the array
     * @throws InvalidFieldException The index does not match a known field
     * @throws InvalidFieldValueException The value provided is out of range
     *    for the field type.
     */
    public void setValue(int index, String[] value, int numValid)
        throws InvalidFieldException, InvalidFieldValueException {

        if(fieldDeclList.get(index) == null)
            throw new InvalidFieldException("Unknown field index");

        if (backFill) {
            Object old_value = fieldValueMap.get(index);
            if (old_value != null) {
                if (old_value instanceof String) {
                    value = new String[1];
                    value[0] = (String)old_value;
                }
                else
                    value = (String[]) old_value;
                numValid = ((Integer)fieldSizeMap.get(index)).intValue();
            }
            else {
                fieldSizeMap.put(index, new Integer(numValid));
                fieldValueMap.put(index, value);
                fieldChangedMap.put(index, Boolean.TRUE);
                fireFieldChanged(index);
            }
        } else {
            Integer curr_size = (Integer)fieldSizeMap.get(index);
            if(curr_size == null || curr_size.intValue() != numValid)
                fieldSizeMap.put(index, new Integer(numValid));

            fieldValueMap.put(index, value);
            fieldChangedMap.put(index, Boolean.TRUE);
            fireFieldChanged(index);
        }

        // now set the value to all the fields that are ISd
        ProtoFieldInfo[] is_list = (ProtoFieldInfo[])isMap.get(index);

        if(is_list == null)
            return;

        exposedEvent = true;

        for(int i = 0; i < is_list.length; i++)
            is_list[i].node.setValue(is_list[i].field, value, numValid);

        exposedEvent = false;
    }

    /**
     * Set the value of the field at the given index as a node. This would be
     * used to set SFNode field types.
     *
     * @param index The index of destination field to set
     * @param child The new value to use for the node
     * @throws InvalidFieldException The index does not match a known field
     * @throws InvalidFieldValueException The value provided is out of range
     *    for the field type.
     */
    public void setValue(int index, VRMLNodeType child)
        throws InvalidFieldException, InvalidFieldValueException {

        VRMLFieldDeclaration decl = (VRMLFieldDeclaration) fieldDeclList.get(index);

        if(decl == null)
            throw new InvalidFieldException("Unknown field index");

        if (backFill) {
            Object old_value = fieldValueMap.get(index);
            if (old_value != null)
                child = (VRMLNodeType) old_value;
            else {
                fieldSizeMap.put(index, SINGLE_SIZE);
                fieldValueMap.put(index, child);
                fieldChangedMap.put(index, Boolean.TRUE);
                fireFieldChanged(index);
            }
        } else {
            // Need to treat singleton calls differently during setup.
            // Don't want append logic during resendIS time, only parsing.

            // TODO: How should this interact during backFill?
            if (decl.getFieldType() == FieldConstants.MFNODE && inSetup && !resendingIS) {
                Object old_value = fieldValueMap.get(index);
                if (old_value == null) {
                    fieldValueMap.put(index, child);
                    fieldSizeMap.put(index, SINGLE_SIZE);
                } else {
                    VRMLNodeType[] childs;

                    if (old_value instanceof VRMLNodeType) {
                        childs = new VRMLNodeType[2];
                        childs[0] = (VRMLNodeType)old_value;
                        childs[1] = child;
                    } else {
                        VRMLNodeType[] old_array = (VRMLNodeType[]) old_value;
                        int cnt = old_array.length;
                        childs = new VRMLNodeType[cnt+1];
                        for(int i = 0; i < cnt; i++)
                           childs[i] = old_array[i];

                        childs[cnt] = child;
                    }

                    fieldValueMap.put(index, childs);
                    fieldSizeMap.put(index, new Integer(childs.length));
                }

            } else {
                fieldSizeMap.put(index, SINGLE_SIZE);
                fieldValueMap.put(index, child);
            }
            fieldChangedMap.put(index, Boolean.TRUE);
            fireFieldChanged(index);
        }

        // now set the value to all the fields that are ISd
        ProtoFieldInfo[] is_list = (ProtoFieldInfo[])isMap.get(index);

        if(is_list == null)
            return;

        exposedEvent = true;

/*
NOTE:
 See comment in method below about why this is commented out.

        if(child instanceof VRMLGroupingNodeType) {

            VRMLGroupingNodeType grp =
                (VRMLGroupingNodeType)child;

            for(int i = 0; i < is_list.length; i++) {
                grp.setShared(true);
            }
        } else if(child instanceof VRMLProtoInstance) {

            VRMLProtoInstance proto = (VRMLProtoInstance)child;
            VRMLNodeType impl = proto.getImplementationNode();

            if(impl instanceof VRMLGroupingNodeType) {
                VRMLGroupingNodeType grp =
                    (VRMLGroupingNodeType)impl;

                for(int i = 0; i < is_list.length; i++) {
                    grp.setShared(true);
                }
            }
        }
*/
        for(int i = 0; i < is_list.length; i++)
            is_list[i].node.setValue(is_list[i].field, child);

        exposedEvent = false;
    }

    /**
     * Set the value of the field at the given index as an array of nodes.
     * This would be used to set MFNode field types.
     *
     * @param index The index of destination field to set
     * @param children The new value to use for the node
     * @param numValid The number of valid values to copy from the array
     * @throws InvalidFieldException The index does not match a known field
     * @throws InvalidFieldValueException The value provided is out of range
     *    for the field type.
     */
    public void setValue(int index, VRMLNodeType[] children, int numValid)
        throws InvalidFieldException, InvalidFieldValueException {

        if(fieldDeclList.get(index) == null)
            throw new InvalidFieldException("Unknown field index");

        if(backFill) {
            Object old_value = fieldValueMap.get(index);
            if(old_value != null) {
                children = (VRMLNodeType[])old_value;
                numValid = ((Integer)fieldSizeMap.get(index)).intValue();
            } else {
                fieldSizeMap.put(index, new Integer(numValid));
                fieldValueMap.put(index, children);
                fieldChangedMap.put(index, Boolean.TRUE);
                fireFieldChanged(index);
            }
        } else {
            Integer curr_size = (Integer)fieldSizeMap.get(index);
            if(curr_size == null || curr_size.intValue() != numValid)
                fieldSizeMap.put(index, new Integer(numValid));

            fieldValueMap.put(index, children);
            fieldChangedMap.put(index, Boolean.TRUE);
            fireFieldChanged(index);
        }

        // now set the value to all the fields that are ISd
        ProtoFieldInfo[] is_list = (ProtoFieldInfo[])isMap.get(index);

        if(is_list == null)
            return;

        exposedEvent = true;
        for(int i = 0; i < is_list.length; i++) {
/*
Commented out because I don't think that any node needs to be
referenced twice. Causes the shareCount to be set to 2 for the
situation of
PROTO foo [ inputOutput MFNode kids [] ]
{ Group { children IS kids }}

foo {
    kids Shape {}
}

Shape has a ref count of 2 - which prevents bindable nodes from
being accepted - bad thing, because it should. Really the proto
definition does not form part of the active scene graph. However,
if the field was not IS'd to an internal node, the shareCount would
be 0, which we don't really want either. probably should be 1.
Seems to work for all content we've encountered so far, so leaving
as is for now.

            for(int k = 0; k < children.length; k++) {
                VRMLNodeType child = children[k];

                if(child instanceof VRMLGroupingNodeType) {
                    VRMLGroupingNodeType grp =
                        (VRMLGroupingNodeType)child;

                    for(int j = 0; j < is_list.length; j++) {
                        grp.setShared(true);
                    }
                } else if(child instanceof VRMLProtoInstance) {

                    VRMLProtoInstance proto = (VRMLProtoInstance)child;
                    VRMLNodeType impl = proto.getImplementationNode();

                    if(impl instanceof VRMLGroupingNodeType) {
                        VRMLGroupingNodeType grp =
                            (VRMLGroupingNodeType)impl;

                        for(int j = 0; j < is_list.length; j++) {
                            grp.setShared(true);
                        }
                    }
                }
            }
*/
            is_list[i].node.setValue(is_list[i].field, children, numValid);
        }

        exposedEvent = false;
    }

    //----------------------------------------------------------
    // Methods defined by VRMLExternalNodeType
    //----------------------------------------------------------

    /**
     * Get the contained scene graph that this instance has. This represents
     * everything about the internal scene that the node declaration wraps.
     * This is a real-time representation so that if it the nodes contains a
     * script that changes the internal representation then this instance will
     * be updated to reflect and changes made.
     *
     * @return The scene contained by this node instance
     */
    public BasicScene getContainedScene() {
        return sceneInfo;
    }

    //----------------------------------------------------------
    // Local methods
    //----------------------------------------------------------

    /**
     * Append a field declaration to this node. This is added to the current
     * list on the end. If the field already exists with the given name but
     * different values exception will be generated. If the field has exactly
     * the same signature it will silently ignore the request.
     *
     * @param field The new field to add
     * @return The index that this field was added at
     * @throws FieldExistsException A conflicting field of the same name
     *   already exists for this node
     */
    protected int appendField(VRMLFieldDeclaration field)
        throws FieldExistsException {

        String name = field.getName();

        // Test for conflicting field name
        Integer pos_index = (Integer)fieldIndexMap.get(name);
        if(pos_index != null) {

            VRMLFieldDeclaration existing =
                (VRMLFieldDeclaration)fieldDeclList.get(pos_index.intValue());

            if((field.getFieldType() != existing.getFieldType()) ||
               (field.getAccessType() != field.getAccessType()))
                throw new FieldExistsException(FIELD_CLASH_MSG, name);
        }


        fieldIndexMap.put(name, new Integer(lastFieldIndex));
        fieldDeclList.add(field);

        return lastFieldIndex++;
    }

    /**
     * Add another node to the internal defintion of the node. The first item
     * set will be registered as the formal type of this instance. When this is
     * called, the node should have already been told that its setup is
     * complete.
     *
     * @param node The node instance to add
     */
    void addBodyChild(VRMLNodeType node) {
        bodyNodes[bodyNodeCount] = node;
        bodyNodeCount++;
    }

    /**
     * Change the number of body nodes in this proto.  This can only be called
     * before body nodes are added.  This allows extern protos to define the
     * interface and later fill in the body group
     */
    void setNumBodyNodes(int num) {
        if (bodyNodeCount != 0) {
            throw new IllegalStateException("Cannot set numBodyCount after " +
                "adding children to " + getVRMLNodeName());
        }

        bodyNodes = new VRMLNodeType[num];
    }

    /**
     * Set the mapping of import statements to their proxy instances. The map
     * will be copied into an internal version.
     *
     * @param imports The mapping of import names to ImportNodeProxy instances
     */
    void setImports(Map imports) {
        proxyNodeMap.putAll(imports);
    }

    /**
     * Specify we are backfilling the protobody.  This will ignore setValues
     * that overwrite values specified in the declaration of the extern proto
     * instance
     *
     * @param val True if we are backfilling
     */
    void setBackFill(boolean val) {
        backFill = val;

    }

    /**
     * Denote that this proto is complete and ready to use.  Extern protos and
     * local protos resolve completeness differently so this cannot be in the
     * finishCreate method.
     */
    public void setComplete() {
        // Layer all body nodes

        // TODO: I suspect we could still get a timing error with this
        if (bodyNotCounted) {
            bodyNotCounted = false;
            for(int i = 0; i < layerIds.length; i++) {
                for(int j = 0; j < bodyNodes.length; j++) {
                    bodyNodes[j].updateRefCount(i, true);
                }
            }
        }

        completeBody = true;
    }

    /**
     * Find out whether this proto is complete and ready to use.
     *
     * @return Is the proto ready to use?
     */
    public boolean getComplete() {
       return completeBody;
    }

    /**
     * Set the mapping of node instances for the given field index. Assumes
     * a valid field index.
     *
     * @param index The field index we are registering the list for
     * @param destList The list of node ProtoFieldInfos for the IS values
     */
    void setIsMapping(int index, List destList) {

        int size = destList.size();
        ProtoFieldInfo[] info = new ProtoFieldInfo[size];
        destList.toArray(info);
        isMap.put(index, info);

        VRMLFieldDeclaration decl = getFieldDeclaration(index);
        int access_type = decl.getAccessType();

        // If this field has output capabilities, register adapters for
        // them.
        if(access_type == FieldConstants.EXPOSEDFIELD ||
           access_type == FieldConstants.EVENTOUT) {
            for(int i = 0; i < size; i++) {
                VRMLNodeListener l =
                    new ISFieldAdapter(index, info[i].node, info[i].field);
                info[i].node.addNodeListener(l);
            }
        }
    }

    /**
     * Resend the IS values.  This is called after the proto body is created
     * in an extern proto.
     */
    void resendIS() {
        Iterator itr = uniqueFieldIndexMap.values().iterator();
        int idx;
        ProtoFieldInfo[] is_list;
        VRMLFieldDeclaration decl;

        resendingIS = true;

        while(itr.hasNext()) {
            idx = ((Integer) itr.next()).intValue();

            decl = getFieldDeclaration(idx);
            int accessType = decl.getAccessType();
            if (accessType == FieldConstants.EVENTIN ||
                accessType == FieldConstants.EVENTOUT) {

                continue;
            }

            is_list = (ProtoFieldInfo[])isMap.get(idx);

            if(is_list == null)
                continue;

            Object field_val = fieldValueMap.get(idx);

            if(field_val == null)
                continue;

            Integer size = (Integer)fieldSizeMap.get(idx);

            try {
                sendValue(this, idx, field_val, size.intValue());
            } catch (InvalidFieldValueException ifve) {
                ifve.printStackTrace();
            } catch (InvalidFieldException ife) {
                ife.printStackTrace();
            }
        }

        // No longer needed
        uniqueFieldIndexMap = null;
        resendingIS = false;
    }

    /**
     * Set the scene information that this proto contains.
     *
     * @param sc The scene reference
     */
    void setContainedScene(ProtoScene sc) {
        sceneInfo = sc;

        if((rootNode == null) && (bodyNodeCount != 0)) {
            rootNode = bodyNodes[0];

            // time to go looking for the real secondary types. Recurse
            // the definitions until one finds something that is not a proto.
            int body_type = rootNode.getPrimaryType();

            if(body_type == TypeConstants.ProtoInstance)
                secondaryType = rootNode.getSecondaryType();
            else
                secondaryType = new int[] { body_type };
        }

        if(isDEF && (rootNode != null))
            rootNode.setDEF();
    }

    /**
     * Walk the proto's body group and call setup finished on each node
     */
    void propagateSetupFinished() {

        if(propogated || !completeBody || (rootNode == null))
            return;

        propogated = true;

        // Do the node fields first.
        VRMLFieldDeclaration decl;
        int i;
        int access_type;
        int field_type;
        int num_fields = getFieldCount();
        for(i = 0; i < num_fields; i++) {
            decl = (VRMLFieldDeclaration)fieldDeclList.get(i);

            access_type = decl.getAccessType();

            if((access_type == FieldConstants.EVENTIN) ||
               (access_type == FieldConstants.EVENTOUT))
                continue;

            field_type = decl.getFieldType();

            if((field_type != FieldConstants.MFNODE) ||
               (field_type != FieldConstants.SFNODE))
                continue;

            Object value = fieldValueMap.get(i);

            if(value instanceof VRMLNodeType) {
                VRMLNodeType s_node = (VRMLNodeType)value;
                s_node.setupFinished();
            } else if (value instanceof VRMLNodeType[]) {
                // It may have been null too, so always check....
                VRMLNodeType[] m_node = (VRMLNodeType[])value;

                for(int j = 0; j < m_node.length; j++)
                    m_node[i].setupFinished();
            }
        }

        for(i = 0; i < bodyNodes.length; i++)
            bodyNodes[i].setupFinished();

        if(stateManager == null)
            delayedAdd = true;
    }

    /**
     * Inform the state manager now of the contents of this proto, if we have
     * an instance around. Also, turn off any update flags.
     */
    void sendUpdateMessage() {
        if(stateManager != null) {
            stateManager.registerAddedScene(this);
            delayedAdd = false;
        } else
            delayedAdd = true;
    }

    //----------------------------------------------------------
    // Internal convenience  methods
    //----------------------------------------------------------

    /**
     * Set the value in the given node.
     *
     * @param destNode The destination node to call setValue() on
     * @param index The field index to call
     * @param value The value representation
     * @throws InvalidFieldException The node does not have that field index
     * @throws InvalidFieldValueException The value provided is out of range
     *    for the field type.
     */
    private void sendValue(VRMLNodeType destNode,
                           int index,
                           Object value,
                           int numValid)
        throws InvalidFieldException, InvalidFieldValueException {

        VRMLFieldDeclaration decl = destNode.getFieldDeclaration(index);

        switch(decl.getFieldType()) {
            case FieldConstants.SFINT32:
                destNode.setValue(index, ((Integer)value).intValue());
                break;

            case FieldConstants.MFINT32:
            case FieldConstants.SFIMAGE:
            case FieldConstants.MFIMAGE:
                destNode.setValue(index, (int[])value, numValid);
                break;

            case FieldConstants.SFFLOAT:
                destNode.setValue(index, ((Float)value).floatValue());
                break;

            case FieldConstants.SFTIME:
            case FieldConstants.SFDOUBLE:
                destNode.setValue(index, ((Double)value).doubleValue());
                break;

            case FieldConstants.MFTIME:
            case FieldConstants.MFDOUBLE:
                destNode.setValue(index, (double[])value, numValid);
                break;

            case FieldConstants.SFLONG:
                destNode.setValue(index, ((Long)value).longValue());
                break;

            case FieldConstants.MFLONG:
                destNode.setValue(index, (long[])value, numValid);
                break;

            case FieldConstants.SFBOOL:
                destNode.setValue(index, ((Boolean)value).booleanValue());
                break;

            case FieldConstants.MFBOOL:
                destNode.setValue(index, (boolean[])value, numValid);
                break;

            case FieldConstants.SFNODE:
                destNode.setValue(index, (VRMLNodeType)value);
                break;

            case FieldConstants.MFNODE:
                if(value instanceof VRMLNodeType)
                    destNode.setValue(index, (VRMLNodeType)value);
                else
                    destNode.setValue(index, (VRMLNodeType[])value, numValid);
                break;

            case FieldConstants.SFROTATION:
            case FieldConstants.MFFLOAT:
            case FieldConstants.SFVEC2F:
            case FieldConstants.SFVEC3F:
            case FieldConstants.SFVEC4F:
            case FieldConstants.SFCOLOR:
            case FieldConstants.SFCOLORRGBA:
            case FieldConstants.SFMATRIX3F:
            case FieldConstants.SFMATRIX4F:
                destNode.setValue(index, (float[])value, numValid);
                break;

            case FieldConstants.MFROTATION:
            case FieldConstants.MFVEC2F:
            case FieldConstants.MFVEC3F:
            case FieldConstants.MFVEC4F:
            case FieldConstants.MFCOLOR:
            case FieldConstants.MFCOLORRGBA:
            case FieldConstants.MFMATRIX3F:
            case FieldConstants.MFMATRIX4F:
                destNode.setValue(index, (float[])value, numValid);
                break;

            case FieldConstants.SFVEC3D:
            case FieldConstants.SFVEC4D:
            case FieldConstants.SFMATRIX3D:
            case FieldConstants.SFMATRIX4D:
                destNode.setValue(index, (double[])value, numValid);
                break;

            case FieldConstants.MFVEC3D:
            case FieldConstants.MFVEC4D:
            case FieldConstants.MFMATRIX3D:
            case FieldConstants.MFMATRIX4D:
                destNode.setValue(index, (double[])value, numValid);
                break;

            case FieldConstants.MFSTRING:
                destNode.setValue(index, (String[])value, numValid);
                break;

            case FieldConstants.SFSTRING:
                destNode.setValue(index, (String)value);
                break;

            default:
                System.out.println("Unhandled case in "
                    + "CRProtoInstance.sendValue: " + decl.getFieldTypeString());
        }
    }

    /**
     * Set arbitrary data for a given field. Provided primarily to help the
     * EAI fullfil its requirements, but may be useful elsewhere.
     *
     * @param index The index of destination field to set
     * @param data The item to store for the field
     * @throws InvalidFieldException The field index is not known
     */
    public void setUserData(int index, Object data)
        throws InvalidFieldException {

        if(index < 0 || index > lastFieldIndex)
            throw new InvalidFieldException("Invalid index in getUserData");

        userData.put(index, data);
    }

    /**
     * Fetch the stored user data for a given field index. If nothing is
     * registered, null is returned.
     *
     * @param index The index of destination field to set
     * @return The item stored for the field or null
     * @throws InvalidFieldException The field index is not known
     */
    public Object getUserData(int index) throws InvalidFieldException {
        if(index < 0 || index > lastFieldIndex)
            throw new InvalidFieldException("Invalid index in getUserData");

        return userData.get(index);
    }

    //----------------------------------------------------------
    // Local convenience methods
    //----------------------------------------------------------

    /**
     * Determine whether the field is a default value or has been
     * set by the proto resolving.
     *
     * @param index The index of the field to change.
     * @return Is it a default value
     * @throws InvalidFieldException The field index is not known
     */
    public boolean isDefaultValue(int index) throws InvalidFieldException {

        VRMLFieldDeclaration decl = getFieldDeclaration(index);

        if(decl == null)
            throw new InvalidFieldException(nodeName, index);

        Object value = fieldValueMap.get(index);

        if (value == null)
            return true;
        else
            return false;
    }

    /**
     * Send a notification to the registered listeners that a field has been
     * changed. If no listeners have been registered, then this does nothing,
     * so always call it regardless.
     *
     * @param index The index of the field that changed
     */
    protected void fireFieldChanged(int index) {
        if(nodeListener != null) {
            try {
                nodeListener.fieldChanged(index);
            } catch(Throwable th) {
                th.printStackTrace();
            }
        }
    }
}
