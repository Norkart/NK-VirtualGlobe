/* Generated By:JavaCC: Do not edit this line. VRML97RelaxedParser.java */
/*****************************************************************************
 *                        Web3d Consortium Copyright (c) 2001
 *                               Java Source
 *
 * This source is licensed under the GNU LGPL v2.1
 * Please read http://www.gnu.org/copyleft/lgpl.html for more information
 *
 * This software comes with the standard NO WARRANTY disclaimer for any
 * purpose. Use it at your own risk. If there's a problem you get to fix it.
 *
 *****************************************************************************/
package org.web3d.parser.vrml97;

// Standard imports
import java.io.Reader;
import java.io.InputStream;
import java.io.PrintStream;
import java.io.ByteArrayOutputStream;
import java.util.ArrayList;
import java.util.StringTokenizer;

// Application specific imports
import org.web3d.vrml.lang.*;
import org.web3d.vrml.sav.*;

import org.web3d.util.ErrorReporter;
import org.web3d.util.StringArray;

/**
 * A parser for VRML97 syntax that is not very strict about the incoming
 * syntax.
 * <p>
 * Automatically generated from the JavaCC source grammar VRML97Relaxed.jj
 * The grammar is not a strict interprestation of the VRML97 BNF from Appendix
 * A. You can see what JavaCC thinks the grammar is
 * <a href="doc-files/VRML97Relaxed.html">here</a>
 *
 * @author Justin Couch
 * @version Grammar $Revision: 1.26 $
 */
public class VRML97RelaxedParser implements VRML97RelaxedParserConstants {

    /** Message for parsing report prefixing */
    private static final String PARSE_MSG = "Parsing error: ";

    /** Default size for the string array buffer */
    private static final int DEFAULT_ARRAY_SIZE = 4096;

    /** Increment size for the string array buffer */
    private static final int DEFAULT_ARRAY_INC = 1024;

    /**
     * Inner class implementation of the document locator so that we can use
     * the JavaCC token information for line info
     */
    private class VRMLRelaxedLocator implements Locator {
        /**
         * Get the column number that the error occurred at. This is defined
         * to be the starting column.
         */
        public int getColumnNumber() {
            return token.beginColumn;
        }

        /**
         * Get the line number that the error occurred at. This is defined
         * to be the starting line.
         */
        public int getLineNumber() {
            return token.beginLine;
        }
    }

    // Variables for our general use during parsing

    /** The url of the current document */
    private String documentURL;

    /** Reference to the registered content handler if we have one */
    private StringContentHandler contentHandler;

    /** Reference to the registered route handler if we have one */
    private RouteHandler routeHandler;

    /** Reference to the registered script handler if we have one */
    private ScriptHandler scriptHandler;

    /** Reference to the registered proto handler if we have one */
    private ProtoHandler protoHandler;

    /** Reference to the registered error handler if we have one */
    private ErrorReporter errorHandler;

    /** Reference to our Locator instance to hand to users */
    private Locator locator;

    /** Array for parsing strings */
    private StringArray stringArray;

    /**
     * Create a new parser instance that has all of the handlers set to the
     * given references. These can be overridden with the set methods below.
     * It is safe to pass in null references here.
     *
     * @param is The stream to read characters from
     * @param ch The content handler instance to use
     * @param rh The route handler instance to use
     * @param sh The script handler instance to use
     * @param ph The proto handler instance to use
     * @param eh The error handler instance to use
     */
    public VRML97RelaxedParser(InputStream is,
                               ContentHandler ch,
                               RouteHandler rh,
                               ScriptHandler sh,
                               ProtoHandler ph,
                               ErrorHandler eh) {
        this(is);

        locator = new VRMLRelaxedLocator();
        stringArray = new StringArray(DEFAULT_ARRAY_SIZE, DEFAULT_ARRAY_INC);

        contentHandler = (StringContentHandler) ch;
        routeHandler = rh;
        scriptHandler = sh;
        protoHandler = ph;
        errorHandler = eh;
    }

    /**
     * Create a new parser instance that has all of the handlers set to the
     * given references. These can be overridden with the set methods below.
     * It is safe to pass in null references here.
     *
     * @param rdr The reader to source characters from
     * @param ch The content handler instance to use
     * @param rh The route handler instance to use
     * @param sh The script handler instance to use
     * @param ph The proto handler instance to use
     * @param eh The error handler instance to use
     */
    public VRML97RelaxedParser(Reader rdr,
                               ContentHandler ch,
                               RouteHandler rh,
                               ScriptHandler sh,
                               ProtoHandler ph,
                               ErrorHandler eh) {
        this(rdr);

        locator = new VRMLRelaxedLocator();
        stringArray = new StringArray(DEFAULT_ARRAY_SIZE, DEFAULT_ARRAY_INC);

        contentHandler = (StringContentHandler) ch;
        routeHandler = rh;
        scriptHandler = sh;
        protoHandler = ph;
        errorHandler = eh;
    }

    /**
     * Initialise the internals of the parser at start up. If you are not using
     * the detailed constructors, this needs to be called to ensure that all
     * internal state is correctly set up.
     */
    public void initialize() {
        if(locator == null)
            locator = new VRMLRelaxedLocator();

        stringArray = new StringArray(DEFAULT_ARRAY_SIZE, DEFAULT_ARRAY_INC);
    }

    /**
     * Set the base URL of the document that is about to be parsed. Users
     * should always call this to make sure we have correct behaviour for the
     * ContentHandler's <code>startDocument()</code> call.
     * <p>
     * The URL is cleared at the end of each document run. Therefore it is
     * imperative that it get's called each time you use the parser.
     *
     * @param url The document url to set
     */
    public void setDocumentUrl(String url) {
        documentURL = url;
    }

    /**
     * Fetch the locator used by this parser. This is here so that the user of
     * this parser can ask for it and set it before calling startDocument().
     * Once the scene has started parsing in this class it is too late for the
     * locator to be set. This parser does set it internally when asked for a
     * {@link #Scene()} but there may be other times when it is not set.
     *
     * @return The locator used for syntax errors
     */
    public Locator getDocumentLocator() {

        if(locator == null)
            locator = new VRMLRelaxedLocator();

        return locator;
    }

    /**
     * Set the content handler instance.
     *
     * @param ch The content handler instance to use
     */
    public void setContentHandler(ContentHandler ch) {
        contentHandler = (StringContentHandler) ch;
    }

    /**
     * Set the route handler instance.
     *
     * @param rh The route handler instance to use
     */
    public void setRouteHandler(RouteHandler rh) {
        routeHandler = rh;
    }

    /**
     * Set the script handler instance.
     *
     * @param sh The script handler instance to use
     */
    public void setScriptHandler(ScriptHandler sh) {
        scriptHandler = sh;
    }

    /**
     * Set the proto handler instance.
     *
     * @param ph The proto handler instance to use
     */
    public void setProtoHandler(ProtoHandler ph) {
        protoHandler = ph;
    }

    /**
     * Set the error handler instance.
     *
     * @param eh The error handler instance to use
     */
    public void setErrorHandler(ErrorHandler eh) {
        errorHandler = eh;

        if(eh != null)
            eh.setDocumentLocator(getDocumentLocator());
    }

    /**
     * Set the error reporter instance. If this is also an ErrorHandler
     * instance, the document locator will also be set.
     *
     * @param eh The error handler instance to use
     */
    public void setErrorReporter(ErrorReporter eh) {

        if(eh instanceof ErrorHandler)
            setErrorHandler((ErrorHandler)eh);
        else
            errorHandler = eh;
    }

    /**
     * Convenience method to take a current exception and turns it into
     * a parse exception so that it makes it out of the parser.
     *
     * @param se The SAV exception to be printed
     * @throws The parse exception that matches this
     */
    private void convertException(VRMLException se) throws ParseException {

        boolean handled = false;

        if((se instanceof InvalidFieldException) ||
           (se instanceof InvalidFieldValueException)) {
            if(errorHandler != null) {
                try {
                    errorHandler.warningReport(PARSE_MSG, se);
                    handled = true;
                } catch(VRMLException se1) {
                    se = se1;
                }
            }
        } else {
            if(errorHandler != null) {
                try {
                    errorHandler.errorReport(PARSE_MSG, se);
                    handled = true;
                } catch(VRMLException se1) {
                    se = se1;
                }
            }
        }

        if(!handled) {
            StringBuffer buf =
                new StringBuffer("There's an error in the file:\n");

            buf.append(documentURL);
            buf.append('\n');

            String txt = se.getMessage();
            if(txt == null)
                txt = se.getClass().getName();

            buf.append(txt);
            buf.append('\n');

/*
            buf.append("\nThe exception trace is:\n");

            ByteArrayOutputStream bao = new ByteArrayOutputStream();
            PrintStream printer = new PrintStream(bao);
            se.printStackTrace(printer);

            buf.append(bao.toString());
*/
            throw new ParseException(buf.toString());
        }
    }

    /**
     * Private convenience method to strip the string from the tokeniser of
     * surrounding quotes.
     *
     * @return The current token string minus leading and trailing quotes
     */
    private String stripString() {
        return token.image.substring(1, token.image.length()-1);
    }

// Grammar follows the structure in the ISO spec, except that TOKENS are
// at the bottom. Where we have a rule of the form
// statements ::= statement | statement statements
// this is translated to a single (statement())* expression.
// The empty declaration is handled implicitly by JavaCC

//---------------------------------------------------------------------------
//  Grammar from A.2 General
//---------------------------------------------------------------------------


/**
 * Rule 0 - Parse the complete scene.
 * <pre>
 * vrmlScene ::=
 *     statement* ;
 * </pre>
 * The scene assumes that the caller will make the startDocument() and
 * endDocument() calls on the ContentHandler before and after this method.
 */
  final public void Scene() throws ParseException {
    try {
      label_1:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DEF:
        case USE:
        case PROTO:
        case EXTERNPROTO:
        case ROUTE:
        case SCRIPT:
        case ID:
          ;
          break;
        default:
          jj_la1[0] = jj_gen;
          break label_1;
        }
        Statement();
      }
      jj_consume_token(0);
    } finally {
        // Now clear the document URL so that next call doesn't accidently
        // pick up the URL from the last one. Better to have it empty than
        // invalid
        documentURL = null;
    }
  }

/**
 * Rule 1 - Parse a statement.
 * <pre>
 * statement ::=
 *     nodeStatement |
 *     protoStatement |
 *     routeStatement ;
 * </pre>
 */
  final public void Statement() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DEF:
    case USE:
    case SCRIPT:
    case ID:
      NodeStatement();
      break;
    case PROTO:
    case EXTERNPROTO:
      ProtoStatement();
      break;
    case ROUTE:
      RouteStatement();
      break;
    default:
      jj_la1[1] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

/**
 * Rule 2 - Parse a node statement.
 * <pre>
 * nodeStatement ::=
 *     node |
 *     DEF NodeNameId node |
 *     USE NodeNameId ;
 * </pre>
 */
  final public void NodeStatement() throws ParseException {
    String def_name;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SCRIPT:
    case ID:
      Node(null);
      break;
    case DEF:
      jj_consume_token(DEF);
      def_name = NodeNameId();
      Node(def_name);
      break;
    case USE:
      jj_consume_token(USE);
      def_name = NodeNameId();
        if(contentHandler != null) {
            try {
                contentHandler.useDecl(def_name);
            } catch(VRMLException se) {
                // This will be a warning rather than a full error. Basically
                // ignore the node and keep moving.
                if(errorHandler != null) {
                    try {
                        errorHandler.warningReport(PARSE_MSG, se);
                    } catch(VRMLException se2) {
                        // now we have a problem....
                        convertException(se2);
                    }
                } else {
                    convertException(se);
                }
            }
        }
      break;
    default:
      jj_la1[2] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

/**
 * Rule 3 - Parse a node statement.
 * <pre>
 * rootNodeStatement ::=
 *      node |
 *      DEF NodeNameId node ;
 * </pre>
 */
  final public void RootNodeStatement() throws ParseException {
    String def_name;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SCRIPT:
    case ID:
      Node(null);
      break;
    case DEF:
      jj_consume_token(DEF);
      def_name = NodeNameId();
      Node(def_name);
      break;
    default:
      jj_la1[3] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

/**
 * Rule 2 - Parse a node statement.
 * <pre>
 * protoStatement ::=
 *      proto |
 *      externproto ;
 * </pre>
 */
  final public void ProtoStatement() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PROTO:
      Proto();
      break;
    case EXTERNPROTO:
      ExternProto();
      break;
    default:
      jj_la1[4] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

/**
 * Rule 4 - Parse a PROTO declaration.
 * <pre>
 * proto ::=
 *      PROTO NodeTypeId [ interfaceDeclaration* ] { protoBody } ;
 * </pre>
 */
  final public void Proto() throws ParseException {
    String proto_name;
    try {
      jj_consume_token(PROTO);
      proto_name = NodeTypeId();
      jj_consume_token(LBRACKET);
            if(protoHandler != null)
                    protoHandler.startProtoDecl(proto_name);
      label_2:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case EVENTIN:
        case EVENTOUT:
        case FIELD:
        case EXPOSEDFIELD:
          ;
          break;
        default:
          jj_la1[5] = jj_gen;
          break label_2;
        }
        InterfaceDecl();
      }
      jj_consume_token(RBRACKET);
            if(protoHandler != null)
                protoHandler.endProtoDecl();
      jj_consume_token(LBRACE);
            if(protoHandler != null)
                protoHandler.startProtoBody();
      ProtoBody();
      jj_consume_token(RBRACE);
            if(protoHandler != null)
                protoHandler.endProtoBody();
    } catch (VRMLException se) {
        convertException(se);
        // try to find the end of the node and go to that....

    }
  }

/**
 * Rule 5 - Parse a node statement.
 * <pre>
 * protoBody ::=
 *      protoStatement* rootNodeStatement statement* ;
 * </pre>
 */
  final public void ProtoBody() throws ParseException {
    label_3:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PROTO:
      case EXTERNPROTO:
        ;
        break;
      default:
        jj_la1[6] = jj_gen;
        break label_3;
      }
      ProtoStatement();
    }
    RootNodeStatement();
    label_4:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DEF:
      case USE:
      case PROTO:
      case EXTERNPROTO:
      case ROUTE:
      case SCRIPT:
      case ID:
        ;
        break;
      default:
        jj_la1[7] = jj_gen;
        break label_4;
      }
      Statement();
    }
  }

/**
 * Rule 6 - Parse an interface declaration that allows everything except
 * exposedFields.
 * <pre>
 * restrictedInterfaceDeclaration ::=
 *      eventIn fieldNameId eventId |
 *      eventOut fieldNameId eventId |
 *      field fieldNameId eventId fieldValue ;
 * </pre>
 *  Unfortunately we also need some context information here to know if we are in
 *  A script or a proto to know which handler to call.
 */
  final public void RestrictedInterfaceDecl() throws ParseException {
    int access_type;
    String field_type;
    String field_name;
    Object field_value = null;
    boolean node_field = false;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EVENTIN:
        jj_consume_token(EVENTIN);
            access_type = FieldConstants.EVENTIN;
        field_type = FieldId();
        field_name = FieldNameId();
            if(protoHandler != null)
                protoHandler.protoFieldDecl(access_type,
                                            field_type,
                                            field_name,
                                            field_value);
        break;
      case EVENTOUT:
        jj_consume_token(EVENTOUT);
            access_type = FieldConstants.EVENTOUT;
        field_type = FieldId();
        field_name = FieldNameId();
            if(protoHandler != null)
                protoHandler.protoFieldDecl(access_type,
                                            field_type,
                                            field_name,
                                            field_value);
        break;
      case FIELD:
        jj_consume_token(FIELD);
            access_type = FieldConstants.FIELD;
        field_type = FieldId();
        field_name = FieldNameId();
            // If the field type is MFNode or SFNode then we need to register
            // with the callback the field declaration *before* we start
            // reading the children node.
            if(field_type.endsWith("FNode")) {
                node_field = true;
                if(protoHandler != null)
                    protoHandler.protoFieldDecl(access_type,
                                                field_type,
                                                field_name,
                                                null);
            }
        field_value = FieldValue(field_name);
            // field_value will be null if the field type is SFNode or MFNode
            // Only call these if we have to. If they were of this type then
            // the section above would have already taken care of this call.
            if(!node_field && (protoHandler != null)) {
                    protoHandler.protoFieldDecl(access_type,
                                                field_type,
                                                field_name,
                                                field_value);
            }
        break;
      default:
        jj_la1[8] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (VRMLException se) {
        convertException(se);
        // try to find the end of the node and go to that....

    }
  }

/**
 * Rule 7 - Parse a single field interface declaration.
 * <pre>
 * interfaceDeclaration ::=
 *      restrictedInterfaceDeclaration |
 *      exposedField fieldNameId eventId fieldValue ;
 * </pre>
 */
  final public void InterfaceDecl() throws ParseException {
    int access_type;
    String field_type;
    String field_name;
    Object field_value = null;
    boolean node_field = false;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EVENTIN:
      case EVENTOUT:
      case FIELD:
        RestrictedInterfaceDecl();
        break;
      case EXPOSEDFIELD:
        jj_consume_token(EXPOSEDFIELD);
            access_type = FieldConstants.EXPOSEDFIELD;
        field_type = FieldId();
        field_name = FieldNameId();
            // If the field type is MFNode or SFNode then we need to register
            // with the callback the field declaration *before* we start
            // reading the children node.
            if(field_type.endsWith("FNode")) {
                node_field = true;
                if(protoHandler != null)
                    protoHandler.protoFieldDecl(access_type,
                                                field_type,
                                                field_name,
                                                null);
            }
        field_value = FieldValue(field_name);
            // field_value will be null if the field type is SFNode or MFNode
            // Only call these if we have to. If they were of this type then
            // the section above would have already taken care of this call.
            if(!node_field && (protoHandler != null))
                protoHandler.protoFieldDecl(access_type,
                                            field_type,
                                            field_name,
                                            field_value);
        break;
      default:
        jj_la1[9] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (VRMLException se) {
        convertException(se);
        // try to find the end of the node and go to that....

    }
  }

/**
 * Rule 9 - Parse a node statement.
 * <pre>
 * externproto ::=
 *      EXTERNPROTO NodeTypeId [ externInterfaceDeclaration* ] URLList ;
 * </pre>
 */
  final public void ExternProto() throws ParseException {
    String proto_name;
    String[] uri_list;
    try {
      jj_consume_token(EXTERNPROTO);
      proto_name = NodeTypeId();
      jj_consume_token(LBRACKET);
            if(protoHandler != null)
                protoHandler.startExternProtoDecl(proto_name);
      label_5:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case EVENTIN:
        case EVENTOUT:
        case FIELD:
        case EXPOSEDFIELD:
          ;
          break;
        default:
          jj_la1[10] = jj_gen;
          break label_5;
        }
        ExternInterfaceDecl();
      }
      jj_consume_token(RBRACKET);
            if(protoHandler != null)
                protoHandler.endExternProtoDecl();
      uri_list = URIList();
            if(protoHandler != null)
                protoHandler.externProtoURI(uri_list);
    } catch (VRMLException se) {
        convertException(se);
        // try to find the end of the node and go to that....

    }
  }

/**
 * Rule 10 - Parse a node statement.
 * <pre>
 * externInterfaceDeclaration ::=
 *      accessType fieldNameId eventId
 * </pre>
 */
  final public void ExternInterfaceDecl() throws ParseException {
    int access_type;
    String field_type;
    String field_name;
    access_type = AccessType();
    field_type = FieldId();
    field_name = FieldNameId();
        if(protoHandler != null) {
            try {
                protoHandler.protoFieldDecl(access_type,
                                            field_type,
                                            field_name,
                                            null);
            } catch(VRMLException se) {
                convertException(se);
                // try to find the end of the node and go to that....
            }
        }
  }

/**
 * Rule 2 - Parse a node statement.
 * <pre>
 * routeStatement ::=
 *      ROUTE NodeNameId . eventOutId TO NodeNameId . eventInId ;
 * </pre>
 */
  final public void RouteStatement() throws ParseException {
    String src_node;
    String src_field;
    String dest_node;
    String dest_field;
    jj_consume_token(ROUTE);
    src_node = NodeNameId();
    jj_consume_token(DOT);
    src_field = FieldNameId();
    jj_consume_token(TO);
    dest_node = NodeNameId();
    jj_consume_token(DOT);
    dest_field = FieldNameId();
        if(routeHandler != null) {
            try {
                routeHandler.routeDecl(src_node,
                                       src_field,
                                       dest_node,
                                       dest_field);
            } catch(VRMLException se) {
                convertException(se);
                // try to find the end of the node and go to that....
            }
        }
  }

/**
 * Rule 11 - Parse an MFField statement - principally a URIList on the
 * EXTERNPROTO.
 * <pre>
 * URLList ::=
 *    "[" STRING_LITERAL* "]" |
 *    STRING_LITERAL ;
 * </pre>
 */
  final public String[] URIList() throws ParseException {
    ArrayList uri_list = new ArrayList();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LBRACKET:
      jj_consume_token(LBRACKET);
      label_6:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case STRING_LITERAL:
          ;
          break;
        default:
          jj_la1[11] = jj_gen;
          break label_6;
        }
        jj_consume_token(STRING_LITERAL);
            uri_list.add(stripString());
      }
      jj_consume_token(RBRACKET);
        String[] ret_val = new String[uri_list.size()];
        uri_list.toArray(ret_val);
        {if (true) return ret_val;}
      break;
    case STRING_LITERAL:
      jj_consume_token(STRING_LITERAL);
        {if (true) return new String[] { stripString() };}
      break;
    default:
      jj_la1[12] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

//---------------------------------------------------------------------------
//  A.3 Node declarations
//---------------------------------------------------------------------------

/**
 * Rule 12 - Parse a node statement.
 * <pre>
 * node ::=
 *      nodeTypeId { nodeBody } |
 *      "Script" { scriptBody } ;
 *  We also handle the empty cases for both body and script here
 * </pre>
 */
  final public void Node(String defName) throws ParseException {
    String node_name;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ID:
        node_name = Id();
        jj_consume_token(LBRACE);
            if(contentHandler != null)
                contentHandler.startNode(node_name, defName);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case PROTO:
        case EXTERNPROTO:
        case ROUTE:
        case ID:
          NodeBody();
          break;
        default:
          jj_la1[13] = jj_gen;
          ;
        }
        jj_consume_token(RBRACE);
            if(contentHandler != null)
                contentHandler.endNode();
        break;
      case SCRIPT:
        jj_consume_token(SCRIPT);
        jj_consume_token(LBRACE);
            if(contentHandler != null)
                contentHandler.startNode("Script", defName);

            if(scriptHandler != null)
                scriptHandler.startScriptDecl();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case PROTO:
        case EVENTIN:
        case EVENTOUT:
        case FIELD:
        case EXTERNPROTO:
        case ROUTE:
        case ID:
          ScriptBody();
          break;
        default:
          jj_la1[14] = jj_gen;
          ;
        }
        jj_consume_token(RBRACE);
            if(scriptHandler != null)
                scriptHandler.endScriptDecl();

            if(contentHandler != null)
                contentHandler.endNode();
        break;
      default:
        jj_la1[15] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (VRMLException se) {
        convertException(se);
        // try to find the end of the node and go to that....

    }
  }

/**
 * Rule 13 - Parse a node statement.
 * <pre>
 * nodeBody ::=
 *      nodeBodyElement |
 *      nodeBodyElement nodeBody
 * </pre>
 *  The empty case is handled in the Node declaration
 */
  final public void NodeBody() throws ParseException {
    label_7:
    while (true) {
      NodeBodyElement();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PROTO:
      case EXTERNPROTO:
      case ROUTE:
      case ID:
        ;
        break;
      default:
        jj_la1[16] = jj_gen;
        break label_7;
      }
    }
  }

/**
 * Rule 14 - Parse a node statement.
 * <pre>
 * nodeBodyElement ::=
 *      fieldNameId fieldValue |
 *      fieldNameId IS fieldNameId |
 *      routeStatement |
 *      protoStatement ;
 * </pre>
 */
  final public void NodeBodyElement() throws ParseException {
    String field_name;
    Object field_value;
    boolean invalid_field = false;
    try {
      if (jj_2_1(2)) {
        // fieldID fieldValue
                field_name = FieldNameId();
            if(contentHandler != null) {
                try {
                    contentHandler.startField(field_name);
                    invalid_field = false;
                } catch(VRMLException se) {
                    invalid_field = true;
                    convertException(se);
                }
            }
        field_value = FieldValue(null);
            // field_value will be null if the field type is SFNode or MFNode
            // Only call these if we have to. If they were of this type then
            // the section above would have already taken care of this call.
            if(!invalid_field && (field_value != null) &&
               (contentHandler != null)) {
                if(field_value instanceof String)
                    contentHandler.fieldValue((String)field_value);
                else
                    contentHandler.fieldValue((String[])field_value);
            }
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ID:
          // fieldNameId IS fieldNameId
                  field_name = FieldNameId();
            if(contentHandler != null) {
                try {
                    contentHandler.startField(field_name);
                    invalid_field = false;
                } catch(VRMLException se) {
                    invalid_field = true;
                    convertException(se);
                }
            }
          jj_consume_token(IS);
          // This doesn't provide protection from
                  field_value = FieldNameId();
                                        // ExposedFields...
            if((protoHandler != null) && !invalid_field) {
                try {
                    protoHandler.protoIsDecl((String)field_value);
                } catch(FieldException fe) {
                    convertException(fe);
                }
            }
          break;
        case ROUTE:
          RouteStatement();
          break;
        case PROTO:
        case EXTERNPROTO:
          ProtoStatement();
          break;
        default:
          jj_la1[17] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    } catch (VRMLException se) {
        convertException(se);
        // try to find the end of the node and go to that....

    }
  }

/**
 * Rule 15 - Parse a node statement.
 * <pre>
 * scriptBody ::=
 *      scriptBodyElement |
 *      scriptBodyElement scriptBody
 * </pre>
 * The empty case is handled in the Node declaration
 */
  final public void ScriptBody() throws ParseException {
    label_8:
    while (true) {
      ScriptBodyElement();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PROTO:
      case EVENTIN:
      case EVENTOUT:
      case FIELD:
      case EXTERNPROTO:
      case ROUTE:
      case ID:
        ;
        break;
      default:
        jj_la1[18] = jj_gen;
        break label_8;
      }
    }
  }

/**
 * Rule 16 - Parse a node statement.
 * <pre>
 * scriptBodyElement ::=
 *      nodeBodyElement |
 *      restrictedInterfaceDeclaration |
 *      eventIn fieldType eventInId IS eventInId |
 *      eventOut fieldType eventOutId IS eventOutId |
 *      field fieldType fieldNameId IS fieldNameId ;
 * </pre>
 */
  final public void ScriptBodyElement() throws ParseException {
    int access_type;
    String field_type;
    String field_name;
    Object field_value;
    String is_name;
    boolean node_field = false;
    try {
      if (jj_2_2(3)) {
        NodeBodyElement();
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case EVENTIN:
          jj_consume_token(EVENTIN);
            access_type = FieldConstants.EVENTIN;
          field_type = FieldId();
          field_name = FieldNameId();
            if(scriptHandler != null)
                scriptHandler.scriptFieldDecl(access_type,
                                              field_type,
                                              field_name,
                                              null);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case IS:
            jj_consume_token(IS);
            is_name = FieldNameId();
                if(protoHandler != null)
                    protoHandler.protoIsDecl(is_name);
            break;
          default:
            jj_la1[19] = jj_gen;
            ;
          }
          break;
        case EVENTOUT:
          jj_consume_token(EVENTOUT);
            access_type = FieldConstants.EVENTOUT;
          field_type = FieldId();
          field_name = FieldNameId();
            if(scriptHandler != null)
                scriptHandler.scriptFieldDecl(access_type,
                                              field_type,
                                              field_name,
                                              null);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case IS:
            jj_consume_token(IS);
            is_name = FieldNameId();
                if(protoHandler != null)
                    protoHandler.protoIsDecl(is_name);
            break;
          default:
            jj_la1[20] = jj_gen;
            ;
          }
          break;
        case FIELD:
          jj_consume_token(FIELD);
            access_type = FieldConstants.FIELD;
          field_type = FieldId();
          field_name = FieldNameId();
            // If the field type is MFNode or SFNode then we need to register
            // with the callback the field declaration *before* we start
            // reading the children node.
            if(field_type.endsWith("FNode")) {

                node_field = true;
                if(scriptHandler != null)
                    scriptHandler.scriptFieldDecl(access_type,
                                                  field_type,
                                                  field_name,
                                                  null);
            }
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case IS:
            jj_consume_token(IS);
            is_name = FieldNameId();
                if(scriptHandler != null && !node_field)
                    scriptHandler.scriptFieldDecl(access_type,
                                                  field_type,
                                                  field_name,
                                                  null);
                if(protoHandler != null)
                    protoHandler.protoIsDecl(is_name);
            break;
          case NUMBER_LITERAL:
          case STRING_LITERAL:
          case LBRACKET:
          case DEF:
          case USE:
          case NULL:
          case SCRIPT:
          case TRUE:
          case FALSE:
          case ID:
            field_value = FieldValue(field_name);
                // field_value will be null if the field type is SFNode or MFNode
                // Only call these if we have to. If they were of this type then
                // the section above would have already taken care of this call.
                if(!node_field && (scriptHandler != null)) {
                    scriptHandler.scriptFieldDecl(access_type,
                                                  field_type,
                                                  field_name,
                                                  field_value);
                }
            break;
          default:
            jj_la1[21] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          break;
        default:
          jj_la1[22] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    } catch (VRMLException se) {
        convertException(se);
        // try to find the end of the node and go to that....

    }
  }

/**
 * Rule 17 - Parse a node statement.
 * <pre>
 * nodeNameId ::= Id ;
 * </pre>
 */
  final public String NodeNameId() throws ParseException {
    String id;
    id = Id();
                {if (true) return id;}
    throw new Error("Missing return statement in function");
  }

/**
 * Rule 18 - Parse a NodeType identifier.
 * <pre>
 * nodeTypeId ::= Id ;
 * </pre>
 */
  final public String NodeTypeId() throws ParseException {
    String id;
    id = Id();
                {if (true) return id;}
    throw new Error("Missing return statement in function");
  }

/**
 * Rule 19 - Parse a field name string.
 * <pre>
 * fieldNameId ::= Id ;
 * eventInId ::= Id ;
 * eventOutId ::= Id ;
 * exposedFieldId ::= Id ;
 * </pre>
 */
  final public String FieldNameId() throws ParseException {
    String id;
    id = Id();
                {if (true) return id;}
    throw new Error("Missing return statement in function");
  }

/**
 * Rule 20 - Turn a string into the {@link org.web3d.vrml.lang.FieldConstants}
 * value.
 * <pre>
 *    "field" = FieldConstants.FIELD;
 *    "eventIn" = FieldConstants.EVENTIN;
 *    "eventOut" = FieldConstants.EVENTOUT;
 *    "exposedField" = FieldConstants.EXPOSEDFIELD;
 * </pre>
 */
  final public int AccessType() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case FIELD:
      jj_consume_token(FIELD);
              {if (true) return FieldConstants.FIELD;}
      break;
    case EVENTIN:
      jj_consume_token(EVENTIN);
                {if (true) return FieldConstants.EVENTIN;}
      break;
    case EVENTOUT:
      jj_consume_token(EVENTOUT);
                 {if (true) return FieldConstants.EVENTOUT;}
      break;
    case EXPOSEDFIELD:
      jj_consume_token(EXPOSEDFIELD);
                     {if (true) return FieldConstants.EXPOSEDFIELD;}
      break;
    default:
      jj_la1[23] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/**
 * Rule 21 - Turn a string into the {@link org.web3d.vrml.lang.FieldConstants}
 * value.
 * Restricted declaration of a field type of "field" "eventIn" and "eventOut"
 * but does not allow "exposedField"
 * <pre>
 *    "field" = FieldConstants.FIELD;
 *    "eventIn" = FieldConstants.EVENTIN;
 *    "eventOut" = FieldConstants.EVENTOUT;
 * </pre>
 */
  final public int RestrictedFieldType() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case FIELD:
      jj_consume_token(FIELD);
              {if (true) return FieldConstants.FIELD;}
      break;
    case EVENTIN:
      jj_consume_token(EVENTIN);
                {if (true) return FieldConstants.EVENTIN;}
      break;
    case EVENTOUT:
      jj_consume_token(EVENTOUT);
                 {if (true) return FieldConstants.EVENTOUT;}
      break;
    default:
      jj_la1[24] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/**
 * Rule 22 - Parse a field identifier.
 * <pre>
 *   Id
 * </pre>
 *  Concatention of fieldType that we really only care about the ID if the
 *  user wants to provided expanded types.
 */
  final public String FieldId() throws ParseException {
    String id;
    id = Id();
                {if (true) return id;}
    throw new Error("Missing return statement in function");
  }

/**
 * Rule 23 - Parse a field value statement.
 * <pre>
 *  The value of a field. Just a literral string to pass back to the caller
 *  FieldValue :: =
 *     SingleFieldValue |
 *     MultiFieldValue
 * </pre>
 *
 */
  final public Object FieldValue(String fieldName) throws ParseException {
    Object id = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NUMBER_LITERAL:
    case STRING_LITERAL:
    case DEF:
    case USE:
    case NULL:
    case SCRIPT:
    case TRUE:
    case FALSE:
    case ID:
      id = SingleFieldValue();
      break;
    case LBRACKET:
      id = MultiFieldValue(fieldName);
      break;
    default:
      jj_la1[25] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
        {if (true) return id;}
    throw new Error("Missing return statement in function");
  }

/**
 * Rule 24 - Parse a single value of a field statement.
 * <pre>
 * SingleFieldValue ::=
 *     NodeStatement |         # SFNode
 *     "NULL" |                # empty SFNode or empty MFNode
 *     LiteralValue
 * </pre>
 */
  final public String SingleFieldValue() throws ParseException {
    String id = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DEF:
    case USE:
    case SCRIPT:
    case ID:
      NodeStatement();
      break;
    case NULL:
      jj_consume_token(NULL);
            id = token.image; // give them the NULL string anyway

      break;
    case NUMBER_LITERAL:
    case STRING_LITERAL:
    case TRUE:
    case FALSE:
      id = LiteralValue();
      break;
    default:
      jj_la1[26] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
        {if (true) return id;}
    throw new Error("Missing return statement in function");
  }

/**
 * Rule 25 - Parse a multi value field statement.
 * <pre>
 * MultiFieldValue ::=
 *     "["(NodeStatment)+ "]" | # MFNode
 *     "[ (SingleFieldvalue)* ]
 * </pre>
 */
  final public Object MultiFieldValue(String fieldName) throws ParseException {
    boolean is_nodes = false;
    String[] multi_string = null;
    ArrayList value_list = new ArrayList();
    try {
      jj_consume_token(LBRACKET);
      if (jj_2_3(2)) {
        label_9:
        while (true) {
          NodeStatement();
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case DEF:
          case USE:
          case SCRIPT:
          case ID:
            ;
            break;
          default:
            jj_la1[27] = jj_gen;
            break label_9;
          }
        }
                is_nodes = true;
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case NUMBER_LITERAL:
          multi_string = NumberArray();
          break;
        default:
          jj_la1[28] = jj_gen;
          multi_string = StringArray();
        }
      }
      jj_consume_token(RBRACKET);
            if(contentHandler != null) {
                if(is_nodes) {
                    // Handler for an MFNode field
                    contentHandler.endField();
                } else {

                    // If the multiple value string is empty then we assume
                    // that we have a single value - even if it is not set
                    // This works is for a zero length field - ie "[]"
//                    if(multi_string == null || multi_string.length == 0)
//                        return a_value;
//                    else
                        {if (true) return multi_string;}
                }
            }

            // if all else fails...
            {if (true) return null;}
    } catch (VRMLException se) {
        convertException(se);
        // try to find the end of the node and go to that....

    }
    throw new Error("Missing return statement in function");
  }

/**
 * Rule 26 - Parse a literal value for a single field value.
 * <pre>
 * LiteralValue ::=
 *    TRUE |
 *    FALSE |
 *    NumberArray |
 *    STRING_LITERAL
 * </pre>
 * We do allow a full number array here - ie more than the max 4 values that
 * an SFRotation contains. This makes our parsing faster, but less correct.
 * Basically we assume the callback will deal with any extra numbers if they
 * want to by either discarding them or throwing an error.
 */
  final public String LiteralValue() throws ParseException {
    String id;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TRUE:
      jj_consume_token(TRUE);
                 id = token.image;
      break;
    case FALSE:
      jj_consume_token(FALSE);
                  id = token.image;
      break;
    case NUMBER_LITERAL:
      id = FixedNumberArray();
      break;
    case STRING_LITERAL:
      jj_consume_token(STRING_LITERAL);
                           id = token.image;
      break;
    default:
      jj_la1[29] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
        {if (true) return id;}
    throw new Error("Missing return statement in function");
  }

/**
 * Rule 27 - Parse an array of string literals.
 * <pre>
 * StringArray ::=
 *   STRING_LITERAL+
 * </pre>
 */
  final public String[] StringArray() throws ParseException {
    stringArray.clear();
    label_10:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STRING_LITERAL:
        ;
        break;
      default:
        jj_la1[30] = jj_gen;
        break label_10;
      }
      jj_consume_token(STRING_LITERAL);
        stringArray.add(token.image);
    }
        {if (true) return stringArray.toArray();}
    throw new Error("Missing return statement in function");
  }

/**
 * Rule 28 - Parse a number that may contain multiple whitespace values - such
 * as an SFVec3f.
 * <pre>
 * NumberArray ::=
 *    NUMBER_LITERAL+
 * </pre>
 */
  final public String[] NumberArray() throws ParseException {
    stringArray.clear();
    label_11:
    while (true) {
      jj_consume_token(NUMBER_LITERAL);
            // Must put the spaces back in so that the field parser can deal
            // with the string properly.
            stringArray.add(token.image);
      if (jj_2_4(2)) {
        ;
      } else {
        break label_11;
      }
    }
        {if (true) return stringArray.toArray();}
    throw new Error("Missing return statement in function");
  }

/**
 * Rule 29 - Parse a number that may contain multiple whitespace values - such
 * as an SFVec3f.
 * <pre>
 * NumberArray ::=
 *    NUMBER_LITERAL+
 * </pre>
 */
  final public String FixedNumberArray() throws ParseException {
    StringBuffer value = new StringBuffer();
    label_12:
    while (true) {
      jj_consume_token(NUMBER_LITERAL);
            // Must put the spaces back in so that the field parser can deal
            // with the string properly.
            value.append(' ');
            value.append(token.image);
      if (jj_2_5(2)) {
        ;
      } else {
        break label_12;
      }
    }
        {if (true) return value.toString();}
    throw new Error("Missing return statement in function");
  }

//---------------------------------------------------------------------------
//  Miscellaneous methods to use
//---------------------------------------------------------------------------

/**
 * Generate an identifier as a string from the parsed token.
 */
  final public String Id() throws ParseException {
    jj_consume_token(ID);
           {if (true) return token.image;}
    throw new Error("Missing return statement in function");
  }

  final private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  final private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  final private boolean jj_2_3(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_3(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(2, xla); }
  }

  final private boolean jj_2_4(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_4(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(3, xla); }
  }

  final private boolean jj_2_5(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_5(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(4, xla); }
  }

  final private boolean jj_3R_53() {
    if (jj_scan_token(STRING_LITERAL)) return true;
    return false;
  }

  final private boolean jj_3R_52() {
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_53()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_33() {
    if (jj_3R_38()) return true;
    return false;
  }

  final private boolean jj_3R_42() {
    if (jj_scan_token(SCRIPT)) return true;
    if (jj_scan_token(LBRACE)) return true;
    return false;
  }

  final private boolean jj_3R_32() {
    if (jj_scan_token(NULL)) return true;
    return false;
  }

  final private boolean jj_3R_31() {
    if (jj_3R_23()) return true;
    return false;
  }

  final private boolean jj_3R_13() {
    if (jj_3R_17()) return true;
    return false;
  }

  final private boolean jj_3R_24() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_31()) {
    jj_scanpos = xsp;
    if (jj_3R_32()) {
    jj_scanpos = xsp;
    if (jj_3R_33()) return true;
    }
    }
    return false;
  }

  final private boolean jj_3R_20() {
    if (jj_3R_13()) return true;
    if (jj_scan_token(IS)) return true;
    if (jj_3R_13()) return true;
    return false;
  }

  final private boolean jj_3R_46() {
    if (jj_scan_token(STRING_LITERAL)) return true;
    return false;
  }

  final private boolean jj_3R_41() {
    if (jj_3R_17()) return true;
    if (jj_scan_token(LBRACE)) return true;
    return false;
  }

  final private boolean jj_3R_45() {
    if (jj_3R_50()) return true;
    return false;
  }

  final private boolean jj_3R_44() {
    if (jj_scan_token(FALSE)) return true;
    return false;
  }

  final private boolean jj_3R_43() {
    if (jj_scan_token(TRUE)) return true;
    return false;
  }

  final private boolean jj_3R_37() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_41()) {
    jj_scanpos = xsp;
    if (jj_3R_42()) return true;
    }
    return false;
  }

  final private boolean jj_3R_38() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_43()) {
    jj_scanpos = xsp;
    if (jj_3R_44()) {
    jj_scanpos = xsp;
    if (jj_3R_45()) {
    jj_scanpos = xsp;
    if (jj_3R_46()) return true;
    }
    }
    }
    return false;
  }

  final private boolean jj_3R_49() {
    if (jj_3R_17()) return true;
    return false;
  }

  final private boolean jj_3R_19() {
    if (jj_3R_25()) return true;
    return false;
  }

  final private boolean jj_3R_18() {
    if (jj_3R_24()) return true;
    return false;
  }

  final private boolean jj_3R_17() {
    if (jj_scan_token(ID)) return true;
    return false;
  }

  final private boolean jj_3R_14() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_18()) {
    jj_scanpos = xsp;
    if (jj_3R_19()) return true;
    }
    return false;
  }

  final private boolean jj_3R_30() {
    if (jj_scan_token(USE)) return true;
    if (jj_3R_34()) return true;
    return false;
  }

  final private boolean jj_3R_29() {
    if (jj_scan_token(DEF)) return true;
    if (jj_3R_34()) return true;
    return false;
  }

  final private boolean jj_3_2() {
    if (jj_3R_15()) return true;
    return false;
  }

  final private boolean jj_3R_23() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_28()) {
    jj_scanpos = xsp;
    if (jj_3R_29()) {
    jj_scanpos = xsp;
    if (jj_3R_30()) return true;
    }
    }
    return false;
  }

  final private boolean jj_3R_28() {
    if (jj_3R_37()) return true;
    return false;
  }

  final private boolean jj_3R_34() {
    if (jj_3R_17()) return true;
    return false;
  }

  final private boolean jj_3_1() {
    if (jj_3R_13()) return true;
    if (jj_3R_14()) return true;
    return false;
  }

  final private boolean jj_3_5() {
    if (jj_scan_token(NUMBER_LITERAL)) return true;
    return false;
  }

  final private boolean jj_3R_15() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_1()) {
    jj_scanpos = xsp;
    if (jj_3R_20()) {
    jj_scanpos = xsp;
    if (jj_3R_21()) {
    jj_scanpos = xsp;
    if (jj_3R_22()) return true;
    }
    }
    }
    return false;
  }

  final private boolean jj_3R_50() {
    Token xsp;
    if (jj_3_5()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_5()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_39() {
    if (jj_scan_token(PROTO)) return true;
    if (jj_3R_49()) return true;
    if (jj_scan_token(LBRACKET)) return true;
    return false;
  }

  final private boolean jj_3R_48() {
    if (jj_3R_52()) return true;
    return false;
  }

  final private boolean jj_3R_40() {
    if (jj_scan_token(EXTERNPROTO)) return true;
    if (jj_3R_49()) return true;
    if (jj_scan_token(LBRACKET)) return true;
    return false;
  }

  final private boolean jj_3R_47() {
    if (jj_3R_51()) return true;
    return false;
  }

  final private boolean jj_3R_16() {
    if (jj_3R_23()) return true;
    return false;
  }

  final private boolean jj_3_3() {
    Token xsp;
    if (jj_3R_16()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_16()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3_4() {
    if (jj_scan_token(NUMBER_LITERAL)) return true;
    return false;
  }

  final private boolean jj_3R_36() {
    if (jj_3R_40()) return true;
    return false;
  }

  final private boolean jj_3R_27() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_35()) {
    jj_scanpos = xsp;
    if (jj_3R_36()) return true;
    }
    return false;
  }

  final private boolean jj_3R_35() {
    if (jj_3R_39()) return true;
    return false;
  }

  final private boolean jj_3R_51() {
    Token xsp;
    if (jj_3_4()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_4()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_25() {
    if (jj_scan_token(LBRACKET)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_3()) {
    jj_scanpos = xsp;
    if (jj_3R_47()) {
    jj_scanpos = xsp;
    if (jj_3R_48()) return true;
    }
    }
    return false;
  }

  final private boolean jj_3R_22() {
    if (jj_3R_27()) return true;
    return false;
  }

  final private boolean jj_3R_21() {
    if (jj_3R_26()) return true;
    return false;
  }

  final private boolean jj_3R_26() {
    if (jj_scan_token(ROUTE)) return true;
    if (jj_3R_34()) return true;
    if (jj_scan_token(DOT)) return true;
    return false;
  }

  public VRML97RelaxedParserTokenManager token_source;
  JavaCharStream jj_input_stream;
  public Token token, jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  public boolean lookingAhead = false;
  private boolean jj_semLA;
  private int jj_gen;
  final private int[] jj_la1 = new int[31];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static {
      jj_la1_0();
      jj_la1_1();
   }
   private static void jj_la1_0() {
      jj_la1_0 = new int[] {0x48c2c000,0x48c2c000,0x4800c000,0x48004000,0x420000,0x3c0000,0x420000,0x48c2c000,0x1c0000,0x3c0000,0x3c0000,0x200,0x1200,0x40c20000,0x40de0000,0x48000000,0x40c20000,0x40c20000,0x40de0000,0x2000000,0x2000000,0x7a01d300,0x1c0000,0x3c0000,0x1c0000,0x7801d300,0x7801c300,0x4800c000,0x100,0x30000300,0x200,};
   }
   private static void jj_la1_1() {
      jj_la1_1 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
   }
  final private JJCalls[] jj_2_rtns = new JJCalls[5];
  private boolean jj_rescan = false;
  private int jj_gc = 0;

  public VRML97RelaxedParser(java.io.InputStream stream) {
     this(stream, null);
  }
  public VRML97RelaxedParser(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new JavaCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new VRML97RelaxedParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 31; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 31; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public VRML97RelaxedParser(java.io.Reader stream) {
    jj_input_stream = new JavaCharStream(stream, 1, 1);
    token_source = new VRML97RelaxedParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 31; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 31; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public VRML97RelaxedParser(VRML97RelaxedParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 31; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(VRML97RelaxedParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 31; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  final private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static private final class LookaheadSuccess extends java.lang.Error { }
  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  final private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }

  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

  final public Token getToken(int index) {
    Token t = lookingAhead ? jj_scanpos : token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  final private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.Vector jj_expentries = new java.util.Vector();
  private int[] jj_expentry;
  private int jj_kind = -1;
  private int[] jj_lasttokens = new int[100];
  private int jj_endpos;

  private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      boolean exists = false;
      for (java.util.Enumeration e = jj_expentries.elements(); e.hasMoreElements();) {
        int[] oldentry = (int[])(e.nextElement());
        if (oldentry.length == jj_expentry.length) {
          exists = true;
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              exists = false;
              break;
            }
          }
          if (exists) break;
        }
      }
      if (!exists) jj_expentries.addElement(jj_expentry);
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  public ParseException generateParseException() {
    jj_expentries.removeAllElements();
    boolean[] la1tokens = new boolean[33];
    for (int i = 0; i < 33; i++) {
      la1tokens[i] = false;
    }
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 31; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 33; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.addElement(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.elementAt(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  final public void enable_tracing() {
  }

  final public void disable_tracing() {
  }

  final private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 5; i++) {
    try {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
            case 2: jj_3_3(); break;
            case 3: jj_3_4(); break;
            case 4: jj_3_5(); break;
          }
        }
        p = p.next;
      } while (p != null);
      } catch(LookaheadSuccess ls) { }
    }
    jj_rescan = false;
  }

  final private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}
