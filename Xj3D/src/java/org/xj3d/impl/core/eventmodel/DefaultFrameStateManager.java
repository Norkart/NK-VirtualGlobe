/*****************************************************************************
 *                        Web3d.org Copyright (c) 2001 - 2006
 *                               Java Source
 *
 * This source is licensed under the GNU LGPL v2.1
 * Please read http://www.gnu.org/copyleft/lgpl.html for more information
 *
 * This software comes with the standard NO WARRANTY disclaimer for any
 * purpose. Use it at your own risk. If there's a problem you get to fix it.
 *
 ****************************************************************************/

package org.xj3d.impl.core.eventmodel;

// External imports
// None

// Local imports
import org.web3d.vrml.nodes.*;

import org.web3d.util.ErrorReporter;
import org.web3d.util.DefaultErrorReporter;
import org.web3d.util.HashSet;
import org.web3d.util.IntHashMap;
import org.web3d.util.ObjectArray;
import org.web3d.vrml.lang.VRMLExecutionSpace;
import org.web3d.vrml.lang.VRMLNode;
import org.web3d.vrml.lang.VRMLNodeTemplate;
import org.web3d.vrml.lang.TypeConstants;
import org.web3d.vrml.util.NodeArray;
import org.web3d.vrml.util.NodeTemplateArray;

/**
 * A generalised implementation of the frame state manager interface that can
 * be used with any renderer.
 * <p>
 *
 * @author Justin Couch, Alan Hudson
 * @version $Revision: 1.3 $
 */
public class DefaultFrameStateManager
    implements FrameStateManager,
               SceneGraphTraversalSimpleObserver {

    /** Number of items to create in the initial array size */
    private static final int NUM_FRAME_LISTENERS = 20;

    /** How many do we increment by if we have to resize */
    private static final int NUM_FRAME_INC = 5;

    /** Message to accompany exceptions generated by the frame finished */
    private static final String EOF_NOTIF_MSG =
        "An error was generated during the end of frame processing";

    /** Set of currently registered this frame listeners */
    private HashSet[] registeredFrameStateListeners;

    /**
     * Listing of all the listeners in this frame. There's two of them
     * to allow for double buffering
     */
    private FrameStateListener[][] currentFrameListeners;

    /** Index of the current listener array to add new listeners to */
    private int currentListenerIdx;

    /** Index of the last frame listener in this frame for buffer 0 */
    private int lastFrameStateIndexA;

    /** Index of the last frame listener in this frame for buffer 1 */
    private int lastFrameStateIndexB;

    /** Reporter instance for handing out errors */
    private ErrorReporter errorReporter;

    /** Map of the basic removed nodes listing */
    private IntHashMap removedNodes;

    /** Map of the basic removed index (true/false) listing */
    private IntHashMap removedIndex;

    /** Map of the basic added nodes listing */
    private IntHashMap addedNodes;

    /** Map of the basic added index (true/false) listing */
    private IntHashMap addedIndex;

    /** Listing of all the listened-for node type IDs */
    private int[] nodeTypeList;

    /** List of removed scripts */
    private NodeArray[] removedScripts;

    /** List of added scripts */
    private NodeArray[] addedScripts;

    /** List of removed sensors */
    private NodeArray[] removedSensors;

    /** List of added sensors */
    private NodeArray[] addedSensors;

    /** List of added UrlNodes */
    private NodeArray[] addedUrls;

    /** List of added ExternProtos */
    private NodeTemplateArray[] addedExternProtos;

    /** List of removed view-dependent nodes */
    private NodeArray[] removedViewDependentNodes;

    /** List of added view-dependent nodes */
    private NodeArray[] addedViewDependentNodes;

    /** List of removed bindable nodes */
    private NodeArray[] removedBindables;

    /** List of added bindable nodes */
    private NodeArray[] addedBindables;

    /** List of scenes that were added in this last frame */
    private ObjectArray[] addedScenes;

    /** List of scenes that were removed in this last frame */
    private ObjectArray[] removedScenes;

    /** List of added terrain nodes */
    private NodeArray[] addedTerrains;

    /** List of removed terrain nodes */
    private NodeArray[] removedTerrains;

    /** List of added external synch nodes */
    private NodeArray[] addedExternals;

    /** List of removed external synch nodes */
    private NodeArray[] removedExternals;


    /** Traverser used to handle added/removed nodes */
    protected SceneGraphTraverser traverser;

    /** Flag indicating whether we are in an add or remove traversal */
    private boolean addTraversal;

    /** Index into buffered add/remove lists */
    private int idxRScripts;
    private int idxAScripts;
    private int idxRSensors;
    private int idxASensors;
    private int idxAUrls;
    private int idxAViewDependents;
    private int idxRViewDependents;
    private int idxRBindables;
    private int idxABindables;
    private int idxRScenes;
    private int idxAScenes;
    private int idxRTerrains;
    private int idxATerrains;
    private int idxRExternals;
    private int idxAExternals;
    private int idxAEPs;

    /**
     * Create a new state manager instance.
     */
    public DefaultFrameStateManager() {

        addedNodes = new IntHashMap();
        removedNodes = new IntHashMap();
        addedIndex = new IntHashMap();
        removedIndex = new IntHashMap();

        removedScripts = new NodeArray[2];
        removedScripts[0] = new NodeArray();
        removedScripts[1] = new NodeArray();
        addedScripts = new NodeArray[2];
        addedScripts[0] = new NodeArray();
        addedScripts[1] = new NodeArray();
        removedSensors = new NodeArray[2];
        removedSensors[0] = new NodeArray();
        removedSensors[1] = new NodeArray();
        addedSensors = new NodeArray[2];
        addedSensors[0] = new NodeArray();
        addedSensors[1] = new NodeArray();
        addedUrls = new NodeArray[2];
        addedUrls[0] = new NodeArray();
        addedUrls[1] = new NodeArray();
        removedViewDependentNodes = new NodeArray[2];
        removedViewDependentNodes[0] = new NodeArray();
        removedViewDependentNodes[1] = new NodeArray();
        addedViewDependentNodes = new NodeArray[2];
        addedViewDependentNodes[0] = new NodeArray();
        addedViewDependentNodes[1] = new NodeArray();
        removedBindables = new NodeArray[2];
        removedBindables[0] = new NodeArray();
        removedBindables[1] = new NodeArray();
        addedBindables = new NodeArray[2];
        addedBindables[0] = new NodeArray();
        addedBindables[1] = new NodeArray();
        addedScenes = new ObjectArray[2];
        addedScenes[0] = new ObjectArray();
        addedScenes[1] = new ObjectArray();
        removedScenes = new ObjectArray[2];
        removedScenes[0] = new ObjectArray();
        removedScenes[1] = new ObjectArray();
        removedTerrains = new NodeArray[2];
        removedTerrains[0] = new NodeArray();
        removedTerrains[1] = new NodeArray();
        addedTerrains = new NodeArray[2];
        addedTerrains[0] = new NodeArray();
        addedTerrains[1] = new NodeArray();
        removedExternals = new NodeArray[2];
        removedExternals[0] = new NodeArray();
        removedExternals[1] = new NodeArray();
        addedExternals = new NodeArray[2];
        addedExternals[0] = new NodeArray();
        addedExternals[1] = new NodeArray();
        addedExternProtos = new NodeTemplateArray[2];
        addedExternProtos[0] = new NodeTemplateArray();
        addedExternProtos[1] = new NodeTemplateArray();

        errorReporter = DefaultErrorReporter.getDefaultReporter();

        registeredFrameStateListeners = new HashSet[2];
        registeredFrameStateListeners[0] = new HashSet();
        registeredFrameStateListeners[1] = new HashSet();
        currentFrameListeners = new FrameStateListener[2][NUM_FRAME_LISTENERS];
        currentListenerIdx = 0;
        lastFrameStateIndexA = 0;
        lastFrameStateIndexB = 0;
        traverser = new SceneGraphTraverser();
        traverser.setObserver(this);
        traverser.setErrorReporter(errorReporter);

        idxRScripts = 0;
        idxAScripts = 0;
        idxRSensors = 0;
        idxASensors = 0;
        idxAUrls = 0;
        idxAViewDependents = 0;
        idxRViewDependents = 0;
        idxRBindables = 0;
        idxABindables = 0;
        idxRScenes = 0;
        idxAScenes = 0;
        idxRTerrains = 0;
        idxATerrains = 0;
        idxRExternals = 0;
        idxAExternals = 0;
        idxAEPs = 0;
    }

    /**
     * Add a listener that is interested in knowing when the end of this frame
     * is reached. When this end of frame is reached, the listener will be
     * removed from the internal list. A listener may call this method to
     * register itself more than once in this frame. The manager will
     * automatically remove duplicates and ensure each listener is called only
     * once each frame.
     *
     * @param l The listener to add
     */
    public synchronized void addEndOfThisFrameListener(FrameStateListener l) {

        int idx = currentListenerIdx;

        if(registeredFrameStateListeners[idx].contains(l))
            return;

        // Generates garbage, fix HashSet to use a pool
        registeredFrameStateListeners[idx].add(l);

        if(idx == 0) {
            if(lastFrameStateIndexA == currentFrameListeners[0].length) {
                int new_size = lastFrameStateIndexA + NUM_FRAME_INC;
                FrameStateListener[] tmp = new FrameStateListener[new_size];
                System.arraycopy(currentFrameListeners[0],
                                 0,
                                 tmp,
                                 0,
                                 lastFrameStateIndexA);

                currentFrameListeners[0] = tmp;
            }

            currentFrameListeners[0][lastFrameStateIndexA++] = l;
        } else {
            if(lastFrameStateIndexB == currentFrameListeners[1].length) {
                int new_size = lastFrameStateIndexB + NUM_FRAME_INC;
                FrameStateListener[] tmp = new FrameStateListener[new_size];
                System.arraycopy(currentFrameListeners[1],
                                 0,
                                 tmp,
                                 0,
                                 lastFrameStateIndexB);

                currentFrameListeners[1] = tmp;
            }

            currentFrameListeners[1][lastFrameStateIndexB++] = l;
        }
    }

    /**
     * Register an error reporter with the manager so that any errors generated
     * by the loading of script code can be reported in a nice, pretty fashion.
     * Setting a value of null will clear the currently set reporter. If one
     * is already set, the new value replaces the old.
     *
     * @param reporter The instance to use or null
     */
    public void setErrorReporter(ErrorReporter reporter) {
        errorReporter = reporter;

        // Reset the default only if we are not shutting down the system.
        if(reporter == null)
            errorReporter = DefaultErrorReporter.getDefaultReporter();
    }

    /**
     * Instruct the state manager that you're interested in keeping track of
     * nodes that have been added or removed of the given list of types. These
     * are the primary node types.
     *
     * @param types An array of types to listen for
     */
    public void listenFor(int[] types) {
        for(int i = 0; i < types.length; i++) {
            NodeArray[] nodes = new NodeArray[2];
            nodes[0] = new NodeArray();
            nodes[1] = new NodeArray();

            addedNodes.put(types[i], nodes);

            nodes = new NodeArray[2];
            nodes[0] = new NodeArray();
            nodes[1] = new NodeArray();

            removedNodes.put(types[i], nodes);

            addedIndex.put(types[i], Boolean.FALSE);
            removedIndex.put(types[i], Boolean.FALSE);
        }

        nodeTypeList = addedNodes.keySet();
    }

    /**
     * Remove a type or types(s) that were previously registered as something
     * to listen for. If one or more of the values were not previously
     * registered we ignore that value.
     *
     * @param types An array of types to remove
     */
    public void removeListenFor(int[] types) {
        for(int i = 0; i < types.length; i++) {
            addedNodes.remove(types[i]);
            removedNodes.remove(types[i]);
        }

        int size = (nodeTypeList == null) ? 0 : nodeTypeList.length;

        // Have we just removed everything? If so, delete the array.
        if(size == types.length)
            nodeTypeList = null;
        else
            nodeTypeList = addedNodes.keySet();
    }

    /**
     * Force clearing all state from this manager now. This is used to indicate
     * that a new world is about to be loaded and everything should be cleaned
     * out now.
     */
    public void clear() {
        for(int i = 0; i < lastFrameStateIndexA; i++)
            currentFrameListeners[0][i] = null;

        for(int i = 0; i < lastFrameStateIndexB; i++)
            currentFrameListeners[1][i] = null;

        removedScripts[0].clear();
        addedScripts[0].clear();
        removedSensors[0].clear();
        addedSensors[0].clear();
        addedUrls[0].clear();
        removedViewDependentNodes[0].clear();
        addedViewDependentNodes[0].clear();
        removedBindables[0].clear();
        addedBindables[0].clear();
        removedScenes[0].clear();
        addedScenes[0].clear();
        removedTerrains[0].clear();
        addedTerrains[0].clear();
        addedExternals[0].clear();
        removedExternals[0].clear();
        addedExternProtos[0].clear();

        removedScripts[1].clear();
        addedScripts[1].clear();
        removedSensors[1].clear();
        addedSensors[1].clear();
        addedUrls[1].clear();
        removedViewDependentNodes[1].clear();
        addedViewDependentNodes[1].clear();
        removedBindables[1].clear();
        addedBindables[1].clear();
        removedScenes[1].clear();
        addedScenes[1].clear();
        removedTerrains[1].clear();
        addedTerrains[1].clear();
        removedExternals[1].clear();
        addedExternals[1].clear();
        addedExternProtos[1].clear();

        idxRScripts = 0;
        idxAScripts = 0;
        idxRSensors = 0;
        idxASensors = 0;
        idxAUrls = 0;
        idxAViewDependents = 0;
        idxRViewDependents = 0;
        idxRBindables = 0;
        idxABindables = 0;
        idxRScenes = 0;
        idxAScenes = 0;
        idxRTerrains = 0;
        idxATerrains = 0;
        idxRExternals = 0;
        idxAExternals = 0;
        idxAEPs = 0;

        // Clear the node maps. The same keys are used across all maps.
        int size = nodeTypeList == null ? 0 : nodeTypeList.length;

        for(int i = 0; i < size; i++) {
            NodeArray[] tmp = (NodeArray[])addedNodes.get(nodeTypeList[i]);
            tmp[0].clear();
            tmp[1].clear();

            tmp = (NodeArray[])removedNodes.get(nodeTypeList[i]);
            tmp[0].clear();
            tmp[1].clear();

            addedIndex.put(nodeTypeList[i], Boolean.FALSE);
            removedIndex.put(nodeTypeList[i], Boolean.FALSE);
        }

        registeredFrameStateListeners[0].clear();
        registeredFrameStateListeners[1].clear();
        currentListenerIdx = 0;
		
		traverser.reset();
    }

    /**
     * Notification that the current frame is finished. This should never be
     * called by user code (node implementations). The only caller should be
     * the rendering traversal code that is specific to each engine.
     */
    public void frameFinished() {
        int back_idx  = currentListenerIdx;

        // swap the listener index
        currentListenerIdx = (currentListenerIdx == 0) ? 1 : 0;

        if(back_idx == 0) {
            if(lastFrameStateIndexA == 0)
                return;

            registeredFrameStateListeners[0].clear();
            for(int i = 0; i < lastFrameStateIndexA; i++) {
                try {
                    // TODO: Find out why nulls are getting into this list
                    if (currentFrameListeners[0][i] != null)
                        currentFrameListeners[0][i].allEventsComplete();
                    currentFrameListeners[0][i] = null;
                } catch(Exception e) {
                    errorReporter.errorReport(EOF_NOTIF_MSG, e);
                }
            }
            lastFrameStateIndexA = 0;
        } else {
            if(lastFrameStateIndexB == 0)
                return;

            registeredFrameStateListeners[1].clear();
            for(int i = 0; i < lastFrameStateIndexB; i++) {
                try {
                    // TODO: Find out why nulls are getting into this list
                    if (currentFrameListeners[1][i] != null)
                        currentFrameListeners[1][i].allEventsComplete();
                    currentFrameListeners[1][i] = null;
                } catch(Exception e) {
                    errorReporter.errorReport(EOF_NOTIF_MSG, e);
                }
            }
            lastFrameStateIndexB = 0;
        }
    }

    /**
     * Register a node that has been removed this frame. The caller should make
     * sure the reference count has already been decremented before calling
     * this method.
     *
     * @param node The reference to the node that has been removed
     */
    public synchronized void registerRemovedNode(VRMLNode node) {
        addTraversal = false;
        traverser.reset();
        traverser.traverseGraph(node);
    }

    /**
     * Register nodes that have been removed this frame. The caller should make
     * sure the reference count has already been decremented before calling
     * this method.
     *
     * @param nodes The reference to the nodes that has been removed
     */
    public synchronized void registerRemovedNodes(VRMLNode[] nodes) {
        addTraversal = false;

        for(int i=0; i < nodes.length; i++) {
            if(nodes[i] == null)
                continue;

            traverser.reset();
            traverser.traverseGraph(nodes[i]);
        }
    }

    /**
     * Register a node that has been added this frame. The caller should make
     * sure the reference count has already been decremented before calling
     * this method.
     *
     * @param node The reference to the node that has been removed
     */
    public synchronized void registerAddedNode(VRMLNode node) {
        addTraversal = true;
        traverser.reset();
        traverser.traverseGraph(node);
    }

    /**
     * Register nodes that have been added this frame. The caller should make
     * sure the reference count has already been decremented before calling
     * this method.
     *
     * @param nodes The reference to the nodes that has been removed
     */
    public synchronized void registerAddedNodes(VRMLNode[] nodes) {
        addTraversal = true;

        for(int i=0; i < nodes.length; i++) {
            if (nodes[i] == null)
                continue;
            traverser.reset();
            traverser.traverseGraph(nodes[i]);
        }
    }

    /**
     * Register an execution space that has been added in this frame.
     *
     * @param space The space that has been added this frame
     */
    public synchronized void registerAddedScene(VRMLExecutionSpace space) {
        addedScenes[idxAScenes].add(space);
    }

    /**
     * Register an execution space that has been removed in this frame.
     *
     * @param space The space that has been added this frame
     */
    public synchronized void registerRemovedScene(VRMLExecutionSpace space) {
        removedScenes[idxRScenes].add(space);
    }

    /**
     * Register an externproto declaration as having been loaded this frame.
     * This will be automatically registered as a URL node.
     *
     * @param proto The proto declaration instance to add
     */
    public synchronized void registerAddedExternProto(VRMLNodeTemplate proto) {
        addedExternProtos[idxAEPs].add(proto);
    }

    /**
     * Clear all registered removed nodes now.
     */
    public void clearRemovedNodes() {
        // Clear the backbuffer versions

        removedScripts[idxRScripts == 0 ? 1 : 0].clear();
        removedSensors[idxRSensors == 0 ? 1 : 0].clear();
        removedBindables[idxRBindables == 0 ? 1 : 0].clear();
        removedViewDependentNodes[idxRViewDependents == 0 ? 1 : 0].clear();
        removedExternals[idxRExternals == 0 ? 1 : 0].clear();
        removedScenes[idxRScenes == 0 ? 1 : 0].clear();

        int size = nodeTypeList == null ? 0 : nodeTypeList.length;

        for(int i = 0; i < size; i++) {
            NodeArray[] tmp = (NodeArray[])removedNodes.get(nodeTypeList[i]);
            Boolean val = (Boolean)removedIndex.get(nodeTypeList[i]);

            NodeArray clear_target = tmp[val.booleanValue() ? 1 : 0];

            int size2 = clear_target.size();
            for(int j = 0; j < size2; j++) {
                VRMLNodeType n = (VRMLNodeType)clear_target.get(j);
                n.clearRemovedLayerIds();
            }

            clear_target.clear();
        }
    }

    /**
     * Clear all registered added nodes now.
     */
    public void clearAddedNodes() {
        // Clear the backbuffer versions

        addedScripts[idxAScripts == 0 ? 1 : 0].clear();
        addedSensors[idxASensors == 0 ? 1 : 0].clear();
        addedBindables[idxABindables == 0 ? 1 : 0].clear();
        addedUrls[idxAUrls == 0 ? 1 : 0].clear();
        addedViewDependentNodes[idxAViewDependents == 0 ? 1 : 0].clear();
        addedExternals[idxAExternals == 0 ? 1 : 0].clear();
        addedExternProtos[idxAEPs == 0 ? 1 : 0].clear();

        int size = nodeTypeList == null ? 0 : nodeTypeList.length;

        for(int i = 0; i < size; i++) {
            NodeArray[] tmp = (NodeArray[])addedNodes.get(nodeTypeList[i]);
            Boolean val = (Boolean)addedIndex.get(nodeTypeList[i]);

            tmp[val.booleanValue() ? 0 : 1].clear();
        }
    }

    /**
     * Clear all registered added scenes now
     */
    public void clearAddedScenes() {
        addedScenes[idxAScenes == 0 ? 1 : 0].clear();
    }

    /**
     * Clear all registered added scenes now
     */
    public void clearRemovedScenes() {
        removedScenes[idxAScenes == 0 ? 1 : 0].clear();
    }

    /**
     * Get all the removed nodes of the named type. This shall return an array
     * all the time regardless of whether there is something to process or not.
     * If there is nothing to process, the list shall be empty.
     *
     * @param type The TypeConstant primary type to get the list for
     * @return The list of nodes that need to be processed
     */
    public NodeArray getRemovedNodes(int type) {

        Boolean idx = (Boolean)removedIndex.get(type);

        NodeArray[] tmp = (NodeArray[])removedNodes.get(type);

        if (!idx.booleanValue()) {
            removedIndex.put(type, Boolean.TRUE);
            return tmp[0];
        } else {
            removedIndex.put(type, Boolean.FALSE);
            return tmp[1];
        }
    }

    /**
     * Get all the removed script nodes.
     */
    public NodeArray getRemovedScripts() {
        if (idxRScripts == 0) {
            idxRScripts = 1;
            return removedScripts[0];
        } else {
            idxRScripts = 0;
            return removedScripts[1];
        }
    }

    /**
     * Get the removed sensors.
     */
    public NodeArray getRemovedSensors() {
        if (idxRSensors == 0) {
            idxRSensors = 1;
            return removedSensors[0];
        } else {
            idxRSensors = 0;
            return removedSensors[1];
        }
    }

    /**
     * Get the list of nodes that require view-dependent updates.
     *
     * @return The list of nodes that need to be processed
     */
    public NodeArray getRemovedViewDependents() {
        if (idxRViewDependents == 0) {
            idxRViewDependents = 1;
            return removedViewDependentNodes[0];
        } else {
            idxRViewDependents = 0;
            return removedViewDependentNodes[1];
        }
    }

    /**
     * Get all the removed bindable nodes. This shall return an array all the
     * time regardless of whether there is something to process or not. If
     * there is nothing to process, the list shall be empty.
     *
     * @return The list of nodes that need to be processed
     */
    public NodeArray getRemovedBindables() {
        if (idxRBindables == 0) {
            idxRBindables = 1;
            return removedBindables[0];
        } else {
            idxRBindables = 0;
            return removedBindables[1];
        }
    }

    /**
     * Get the removed scenes.
     *
     * @return The list of scenes that need to be processed
     */
    public ObjectArray getRemovedScenes() {
        if (idxRScenes == 0) {
            idxRScenes = 1;
            return removedScenes[0];
        } else {
            idxRScenes = 0;
            return removedScenes[1];
        }
    }

    /**
     * Get the removed nodes from this last frame of this specified type.  This
     * shall return an array all the time regardless of whether there is
     * something to process or not. If there is nothing to process, the list
     * shall be empty.
     *
     * @return The list of nodes that need to be processed
     */
    public NodeArray getRemovedTerrains() {
        if (idxRTerrains == 0) {
            idxRTerrains = 1;
            return removedTerrains[0];
        } else {
            idxRTerrains = 0;
            return removedTerrains[1];
        }
    }

    /**
     * Get the removed externally synchronised nodes from this last frame. This
     * shall return an array all the time regardless of whether there is
     * something to process or not. If there is nothing to process, the list
     * shall be empty.
     *
     * @return The list of nodes that need to be processed
     */
    public NodeArray getRemovedExtSynchronizedNodes() {
        if (idxRExternals == 0) {
            idxRExternals = 1;
            return removedExternals[0];
        } else {
            idxRExternals = 0;
            return removedExternals[1];
        }
    }

    /**
     * Get all the addd nodes of the named type. This shall return an array
     * all the time regardless of whether there is something to process or not.
     * If there is nothing to process, the list shall be empty.
     *
     * @param type The TypeConstant primary type to get the list for
     * @return The list of nodes that need to be processed
     */
    public NodeArray getAddedNodes(int type) {
        Boolean idx = (Boolean)addedIndex.get(type);

        NodeArray[] tmp = (NodeArray[])addedNodes.get(type);
        if (!idx.booleanValue()) {
            addedIndex.put(type, Boolean.TRUE);
            return tmp[0];
        } else {
            addedIndex.put(type, Boolean.FALSE);
            return tmp[1];
        }
    }

    /**
     * Get the added Sensors.
     *
     * @return The list of nodes that need to be processed
     */
    public NodeArray getAddedSensors() {
        if (idxASensors == 0) {
            idxASensors = 1;
            return addedSensors[0];
        } else {
            idxASensors = 0;
            return addedSensors[1];
        }
    }

    /**
     * Get the scenes that have inserted during this last frame. The scenes
     * are the guts of an externproto or Inline node that will need fitting
     * into the processing mechanism. This shall return an array all the
     * time regardless of whether there is something to process or not. If
     * there is nothing to process, the list shall be empty. The contents of
     * the array shall be instances of
     * {@link org.web3d.vrml.lang.VRMLExecutionSpace}.
     *
     * @return The list of nodes that need to be processed
     */
    public ObjectArray getAddedScenes() {
        if (idxAScenes == 0) {
            idxAScenes = 1;
            return addedScenes[0];
        } else {
            idxAScenes = 0;
            return addedScenes[1];
        }
    }

    /**
     * Get the added nodes with URL fields that will need to have their content
     * loaded for the first time. This list should not include scripts.
     *
     * @return The list of nodes that need to be processed
     */
    public NodeArray getAddedUrlNodes() {
        if (idxAUrls == 0) {
            idxAUrls = 1;
            return addedUrls[0];
        } else {
            idxAUrls = 0;
            return addedUrls[1];
        }
    }

    /**
     * Get the added scripts from this last frame.
     *
     * @return The list of nodes that need to be processed
     */
    public NodeArray getAddedScripts() {
        if (idxAScripts == 0) {
            idxAScripts = 1;
            return addedScripts[0];
        } else {
            idxAScripts = 0;
            return addedScripts[1];
        }
    }

    /**
     * Get the list of nodes that require view-dependent updates.
     *
     * @return The list of nodes that need to be processed
     */
    public NodeArray getAddedViewDependents() {
        if (idxAViewDependents == 0) {
            idxAViewDependents = 1;
            return addedViewDependentNodes[0];
        } else {
            idxAViewDependents = 0;
            return addedViewDependentNodes[1];
        }
    }

    /**
     * Get the added bindable nodes from this last frame. This shall return an
     * array all the time regardless of whether there is something to process
     * or not. If there is nothing to process, the list shall be empty.
     *
     * @return The list of nodes that need to be processed
     */
    public NodeArray getAddedBindables() {
        if (idxABindables == 0) {
            idxABindables = 1;
            return addedBindables[0];
        } else {
            idxABindables = 0;
            return addedBindables[1];
        }
    }

    /**
     * Get the added terrain sources from this last frame.  This
     * shall return an array all the time regardless of whether there is
     * something to process or not. If there is nothing to process, the list
     * shall be empty.
     *
     * @return The list of nodes that need to be processed
     */
    public NodeArray getAddedTerrains() {
        if (idxATerrains == 0) {
            idxATerrains = 1;
            return addedTerrains[0];
        } else {
            idxATerrains = 0;
            return addedTerrains[1];
        }
    }

    /**
     * Get the added externally synchronised nodes from this last frame. This
     * shall return an array all the time regardless of whether there is
     * something to process or not. If there is nothing to process, the list
     * shall be empty.
     *
     * @return The list of nodes that need to be processed
     */
    public NodeArray getAddedExtSynchronizedNodes() {
        if (idxAExternals == 0) {
            idxAExternals = 1;
            return addedExternals[0];
        } else {
            idxAExternals = 0;
            return addedExternals[1];
        }
    }

    /**
     * Get the added extern proto instances.
     *
     * @return The list of templates that need to be processed
     */
    public NodeTemplateArray getAddedExternProtos() {
        if(idxAEPs == 0) {
            idxAEPs = 1;
            return addedExternProtos[0];
        } else {
            idxAEPs = 0;
            return addedExternProtos[1];
        }
    }

    //----------------------------------------------------------
    // Methods required by the SceneGraphSimpleTraverser Interface
    //----------------------------------------------------------

    /**
     * Notification of a child node.
     *
     * @param parent The parent node of this node
     * @param child The child node that is being observed
     * @param field The index of the child field in its parent node
     * @param used true if the node reference is actually a USE
     */
    public void observedNode(VRMLNodeType parent,
                             VRMLNodeType child,
                             int field,
                             boolean used) {

        if(child instanceof VRMLExternalNodeType) {
            if(addTraversal)
                addedUrls[idxAUrls].add(child);
        } else if (child instanceof VRMLTerrainSource) {
            if(addTraversal)
                addedTerrains[idxATerrains].add(child);
            else
                removedTerrains[idxRTerrains].add(child);
        }

        switch(child.getPrimaryType()) {
            case TypeConstants.PickingSensorNodeType:
            case TypeConstants.PointingDeviceSensorNodeType:
            case TypeConstants.DragSensorNodeType:
            case TypeConstants.KeyDeviceSensorNodeType:
            case TypeConstants.EnvironmentalSensorNodeType:
            case TypeConstants.DeviceSensorNodeType:
            case TypeConstants.SensorNodeType:
                if(addTraversal)
                    addedSensors[idxASensors].add(child);
                else
                    removedSensors[idxRSensors].add(child);
                break;
            case TypeConstants.ScriptNodeType:
                if (addTraversal)
                    addedScripts[idxAScripts].add(child);
                else
                    removedScripts[idxRScripts].add(child);
                break;
            case TypeConstants.ViewpointNodeType:
            case TypeConstants.NavigationInfoNodeType:
            case TypeConstants.BackgroundNodeType:
            case TypeConstants.FogNodeType:
            case TypeConstants.BindableNodeType:
                if(addTraversal)
                    addedBindables[idxABindables].add(child);
                else
                    removedBindables[idxRBindables].add(child);
                break;
            case TypeConstants.ProtoInstance:
                if(!used) {
                    if(addTraversal)
                        registerAddedScene((VRMLExecutionSpace)child);
                    else
                        registerRemovedScene((VRMLExecutionSpace)child);
                }

            default:
                // Check to see if it's in the listen-for mapping. We could use
                // either set to see if there's a simple match.
                int type = child.getPrimaryType();
                if(addedNodes.containsKey(type)) {
                    if(addTraversal) {
                        Boolean val = (Boolean)addedIndex.get(type);
                        NodeArray[] tmp = (NodeArray[])addedNodes.get(type);

                        tmp[val.booleanValue() ? 1 : 0].add(child);
                    } else {
                        Boolean val = (Boolean)removedIndex.get(type);
                        NodeArray[] tmp = (NodeArray[])removedNodes.get(type);
                        tmp[val.booleanValue() ? 1 : 0].add(child);
                    }
                }

        }

        int[] secondary_types = child.getSecondaryType();

        for(int i = 0; i < secondary_types.length; i++) {
            switch(secondary_types[i]) {
                case TypeConstants.ExternalSynchronizedNodeType:
                    if(addTraversal)
                        addedExternals[idxAExternals].add(child);
                    else
                        removedExternals[idxRExternals].add(child);
                    break;
                case TypeConstants.ViewDependentNodeType:
                    if (addTraversal)
                        addedViewDependentNodes[idxAViewDependents].add(child);
                    else
                        removedViewDependentNodes[idxRViewDependents].add(child);
            }
        }
    }
}
